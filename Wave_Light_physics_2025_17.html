<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>インタラクティブ物理学習：光波の世界（拡張版）</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #f8fafc;
            color: #1e293b;
        }
        .sticky-nav {
            position: sticky;
            top: 0;
            z-index: 50;
            background-color: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(8px);
        }
        .section-card {
            background-color: #ffffff;
            border-radius: 0.75rem;
            padding: 2rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.05), 0 2px 4px -2px rgb(0 0 0 / 0.05);
            border: 1px solid #e2e8f0;
        }
        .formula-box {
            background-color: #f0f9ff;
            border: 1px solid #bae6fd;
            border-left: 4px solid #0ea5e9;
            padding: 1rem;
            border-radius: 0.5rem;
            color: #0c4a6e;
        }
        .info-box {
            background-color: #fffbeb;
            border: 1px solid #fde68a;
            border-left: 4px solid #facc15;
            padding: 1rem;
            border-radius: 0.5rem;
            color: #78350f;
        }
        .animation-canvas {
            background-color: #ffffff;
            border-radius: 0.5rem;
            border: 1px solid #e2e8f0;
            cursor: grab;
            /* width/heightは個別のクラスまたはstyleで制御 */
        }
        .animation-canvas:active {
            cursor: grabbing;
        }
        
        #waveCanvas {
            cursor: crosshair;
            background-color: #000;
        }
        #interferenceCanvas {
            background-color: #fff;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            margin-bottom: 0.5em;
            font-size: 0.9em;
            color: #555;
        }
        .control-group input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            transition: opacity .2s;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4a90e2;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .control-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4a90e2;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .container {
            width: 100%;
            max-width: 800px;
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            margin-bottom: 2em;
            padding: 1.5em;
            box-sizing: border-box;
        }
        .controls-panel {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 1.5em;
        }
    </style>
</head>
<body class="antialiased">

    <header class="bg-sky-600 text-white text-center py-8">
        <h1 class="text-4xl font-bold">インタラクティブ物理学習</h1>
        <p class="text-xl mt-2">光波の世界を探求しよう</p>
    </header>

    <nav class="sticky-nav shadow-md">
        <div class="max-w-7xl mx-auto px-4">
            <div class="flex flex-wrap justify-center items-center gap-x-4 md:gap-x-6 py-3 text-sm md:text-base">
                <a href="#section-reflection-refraction" class="text-gray-600 hover:text-sky-600 font-semibold transition">反射と屈折</a>
                <a href="#section-lenses" class="text-gray-600 hover:text-sky-600 font-semibold transition">レンズ</a>
                <a href="#section-mirrors" class="text-gray-600 hover:text-sky-600 font-semibold transition">鏡</a>
                <a href="#section-interference" class="text-gray-600 hover:text-sky-600 font-semibold transition">ヤングの実験</a>
                <a href="#section-diffraction-grating" class="text-gray-600 hover:text-sky-600 font-semibold transition">回折格子</a>
                <a href="#section-thin-film" class="text-gray-600 hover:text-sky-600 font-semibold transition">薄膜</a>
                <a href="#section-newton-rings" class="text-gray-600 hover:text-sky-600 font-semibold transition">ニュートンリング</a>
            </div>
        </div>
    </nav>

    <main class="max-w-6xl mx-auto p-4 md:p-8 space-y-16">
        
        <section id="section-reflection-refraction" class="section-card">
            <h2 class="text-3xl font-bold text-sky-700 mb-4">光の反射と屈折</h2>
            <p class="mb-6 text-gray-700">光が異なる物質の境界に進むとき、一部は跳ね返り（反射）、一部は物質の中に入って進む方向を変えます（屈折）。これらの現象は、蜃気楼や光ファイバーなど、身の回りの様々な現象の原理となっています。</p>
            <div class="grid md:grid-cols-2 gap-8">
                <div>
                    <h3 class="text-xl font-semibold mb-2">反射と屈折の法則（スネルの法則）</h3>
                    <canvas id="snellCanvas" class="animation-canvas w-full h-64"></canvas>
                     <div class="mt-2">
                        <label for="snellAngle" class="text-sm font-semibold">入射角 (i): <span id="snellAngleValue">45</span>°</label>
                        <input id="snellAngle" type="range" min="0" max="89" value="45" class="w-full">
                     </div>
                      <div class="mt-2">
                        <label for="snellN2" class="text-sm font-semibold">媒質2の屈折率 (n₂): <span id="snellN2Value">1.5</span> (媒質1: n₁=1.0)</label>
                        <input id="snellN2" type="range" min="0.5" max="2.5" value="1.5" step="0.1" class="w-full">
                     </div>
                     <div class="mt-2 formula-box text-center text-sm">$n_1 \sin i = n_2 \sin r$</div>
                </div>
                <div>
                    <h3 class="text-xl font-semibold mb-2">全反射と光ファイバー</h3>
                    <canvas id="totalInternalReflectionCanvas" class="animation-canvas w-full h-64"></canvas>
                    <div class="mt-2">
                        <label for="tirAngle" class="text-sm font-semibold">入射角 (i): <span id="tirAngleValue">30</span>° (n₁=1.5, n₂=1.0)</label>
                        <input id="tirAngle" type="range" min="0" max="89" value="30" class="w-full">
                    </div>
                    <div class="mt-2 text-center">
                        <p class="text-sm text-gray-600">臨界角 $\theta_c = \sin^{-1}(n_2/n_1) \approx 41.8^\circ$</p>
                        <p id="tirStatus" class="font-bold text-lg mt-2"></p>
                    </div>
                    <p class="text-sm mt-2 text-gray-600">屈折率が大きい媒質から小さい媒質へ、臨界角以上の角度で光が入射すると、光は屈折せず全て反射します（全反射）。光ファイバーはこの原理を利用しています。</p>
                </div>
                 <div class="md:col-span-2 mt-4">
                    <h3 class="text-xl font-semibold mb-2">蜃気楼 (Mirage)</h3>
                    <canvas id="mirageCanvas" class="animation-canvas w-full h-48"></canvas>
                    <p class="text-sm mt-2 text-gray-600">地表近くの空気が暖められると、空気の密度が不均一になり、屈折率が連続的に変化します。これにより、遠くの景色からの光が曲げられ、実際とは違う場所にあるように見えたり、反転して見えたりします。</p>
                </div>
            </div>
        </section>

        <section id="section-lenses" class="section-card">
            <h2 class="text-3xl font-bold text-sky-700 mb-4">レンズの科学</h2>
            <p class="mb-6 text-gray-700">レンズは光を屈折させることで、物体の像を作ります。ここでは単レンズから組み合わせレンズまで、インタラクティブなシミュレーションでその原理を体験します。</p>
            <div class="grid md:grid-cols-2 gap-12">
                <div>
                    <h3 class="text-xl font-semibold mb-2">凸レンズ (実像と虚像)</h3>
                    <canvas id="convexLensCanvas" class="animation-canvas w-full h-72"></canvas>
                    <div class="mt-4">
                        <label for="convexObjectDistance" class="font-semibold">物体距離 a: <span id="convexObjectDistanceValue">30</span></label>
                        <input type="range" id="convexObjectDistance" min="1" max="50" value="30" step="0.5" class="w-full">
                        <label for="convexObjectHeight" class="font-semibold mt-2 block">物体の高さ: <span id="convexObjectHeightValue">20</span></label>
                        <input type="range" id="convexObjectHeight" min="-40" max="40" value="20" step="1" class="w-full">
                         <p class="text-sm text-gray-600 mt-2">焦点距離 f = 15</p>
                    </div>
                    <div id="convexLensInfo" class="mt-2 p-2 bg-gray-100 rounded text-center"></div>
                </div>
                <div>
                    <h3 class="text-xl font-semibold mb-2">凹レンズ (虚像)</h3>
                    <canvas id="concaveLensCanvas" class="animation-canvas w-full h-72"></canvas>
                     <div class="mt-4">
                        <label for="concaveObjectDistance" class="font-semibold">物体距離 a: <span id="concaveObjectDistanceValue">30</span></label>
                        <input type="range" id="concaveObjectDistance" min="1" max="50" value="30" step="0.5" class="w-full">
                        <label for="concaveObjectHeight" class="font-semibold mt-2 block">物体の高さ: <span id="concaveObjectHeightValue">40</span></label>
                        <input type="range" id="concaveObjectHeight" min="-50" max="50" value="40" step="1" class="w-full">
                        <p class="text-sm text-gray-600 mt-2">焦点距離 f = -15</p>
                    </div>
                    <div id="concaveLensInfo" class="mt-2 p-2 bg-gray-100 rounded text-center"></div>
                </div>
            </div>
             <div class="mt-8">
                <h3 class="text-xl font-semibold mb-2">レンズの公式まとめ</h3>
                 <div class="formula-box text-center text-lg">
                    <p>写像公式: $ \frac{1}{a} + \frac{1}{b} = \frac{1}{f} $　　倍率: $ m = -\frac{b}{a} $</p>
                 </div>
                 <p class="text-sm mt-2 text-gray-600">a: 物体距離, b: 像距離, f: 焦点距離 (凸レンズは正, 凹レンズは負)。bが正なら実像、負なら虚像。mが正なら正立像、負なら倒立像。</p>
            </div>
             <div class="mt-8">
                 <h3 class="text-xl font-semibold mb-2">組み合わせレンズ</h3>
                <canvas id="combinedLensCanvas" class="animation-canvas w-full h-80"></canvas>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mt-4 text-sm">
                    <div>
                        <label for="combinedObjectDistance" class="font-semibold">物体距離 $a_1$: <span id="combinedObjectDistanceValue">150</span></label>
                        <input type="range" id="combinedObjectDistance" min="10" max="500" value="150" step="1" class="w-full">
                    </div>
                     <div>
                        <label for="combinedObjectHeight" class="font-semibold">物体の高さ: <span id="combinedObjectHeightValue">20</span></label>
                        <input type="range" id="combinedObjectHeight" min="-50" max="50" value="20" step="1" class="w-full">
                    </div>
                    <div>
                        <label for="lens1FocalLength" class="font-semibold">レンズ1 焦点距離 $f_1$: <span id="lens1FocalLengthValue">100</span></label>
                        <input type="range" id="lens1FocalLength" min="-200" max="200" value="100" step="1" class="w-full">
                    </div>
                     <div>
                        <label for="lens2FocalLength" class="font-semibold">レンズ2 焦点距離 $f_2$: <span id="lens2FocalLengthValue">120</span></label>
                        <input type="range" id="lens2FocalLength" min="-200" max="200" value="120" step="1" class="w-full">
                    </div>
                    <div class="lg:col-span-4">
                        <label for="lensSeparation" class="font-semibold">レンズ間距離 d: <span id="lensSeparationValue">250</span></label>
                        <input type="range" id="lensSeparation" min="0" max="500" value="250" step="1" class="w-full">
                    </div>
                </div>
                <div id="combinedLensInfo" class="mt-2 p-2 bg-gray-100 rounded text-center text-sm"></div>
                <div id="combinedLensAdvancedInfo" class="mt-2 p-2 bg-sky-50 border border-sky-200 rounded text-center text-sm text-sky-800"></div>
                <p class="text-sm mt-2 text-gray-600">複数のレンズを組み合わせることで、より複雑な光学系（カメラのズームレンズや望遠鏡など）を作ることができます。1枚目のレンズが作った像を、2枚目のレンズの物体として考えます。キャンバス上の物体をドラッグして動かすこともできますよ！</p>
            </div>
        </section>
        
        <section id="section-mirrors" class="section-card">
            <h2 class="text-3xl font-bold text-sky-700 mb-4">5. 鏡による像</h2>
            <p class="mb-6 text-gray-700">鏡は光を反射させて像を作ります。球面鏡である凹面鏡と凸面鏡がどのように像を結ぶのか、作図のルールと共に確かめてみましょう。</p>
            <div class="grid md:grid-cols-2 gap-8">
                <div>
                    <h3 class="text-xl font-semibold mb-2">凹面鏡 (実像と虚像)</h3>
                    <canvas id="concaveMirrorCanvas" class="animation-canvas w-full h-80"></canvas>
                    <div class="mt-4">
                        <label for="concaveMirrorObjectDistance" class="font-semibold">物体距離 a: <span id="concaveMirrorObjectDistanceValue">40</span></label>
                        <input type="range" id="concaveMirrorObjectDistance" min="1" max="80" value="40" step="0.5" class="w-full">
                        <label for="concaveMirrorObjectHeight" class="font-semibold mt-2 block">物体の高さ: <span id="concaveMirrorObjectHeightValue">30</span></label>
                        <input type="range" id="concaveMirrorObjectHeight" min="-50" max="50" value="30" step="1" class="w-full">
                    </div>
                    <p class="text-sm text-gray-600 mt-1">焦点距離 f = 20, 球の中心 C = 40</p>
                    <div id="concaveMirrorInfo" class="mt-2 p-2 bg-gray-100 rounded text-center"></div>
                    <div class="mt-6 text-sm space-y-2 p-3 border rounded-lg">
                        <p><strong class="text-blue-600">① 光軸に平行な光線:</strong> 反射して<strong>焦点(F)</strong>を通る。</p>
                        <p><strong class="text-green-600">② 頂点に向かう光線:</strong> <strong>反射の法則</strong>に従い、光軸に対称に反射する。</p>
                        <p><strong class="text-purple-600">③ 焦点を通る光線:</strong> 反射して<strong>光軸に平行</strong>に進む。</p>
                        <p><strong class="text-orange-500">④ 中心の光線:</strong> <strong>球の中心(C)</strong>を通る光は、反射して<strong>同じ経路を戻る</strong>。</p>
                    </div>
                </div>
                <div>
                    <h3 class="text-xl font-semibold mb-2">凸面鏡 (虚像)</h3>
                    <canvas id="convexMirrorCanvas" class="animation-canvas w-full h-80"></canvas>
                    <div class="mt-4">
                        <label for="convexMirrorObjectDistance" class="font-semibold">物体距離 a: <span id="convexMirrorObjectDistanceValue">40</span></label>
                        <input type="range" id="convexMirrorObjectDistance" min="1" max="80" value="40" step="0.5" class="w-full">
                         <label for="convexMirrorObjectHeight" class="font-semibold mt-2 block">物体の高さ: <span id="convexMirrorObjectHeightValue">30</span></label>
                        <input type="range" id="convexMirrorObjectHeight" min="-50" max="50" value="30" step="1" class="w-full">
                    </div>
                    <p class="text-sm text-gray-600 mt-1">焦点距離 f = -20, 球の中心 C = -40</p>
                    <div id="convexMirrorInfo" class="mt-2 p-2 bg-gray-100 rounded text-center"></div>
                    <div class="mt-6 text-sm space-y-2 p-3 border rounded-lg">
                        <p><strong class="text-blue-600">① 光軸に平行な光線:</strong> 反射して<strong>焦点(F)から出たように</strong>進む。</p>
                        <p><strong class="text-green-600">② 頂点に向かう光線:</strong> <strong>反射の法則</strong>に従い、光軸に対称に反射する。</p>
                        <p><strong class="text-purple-600">③ 焦点に向かう光線:</strong> 反射して<strong>光軸に平行</strong>に進む。</p>
                        <p><strong class="text-orange-500">④ 中心の光線:</strong> <strong>球の中心(C)</strong>に向かう光は、反射して<strong>同じ経路を戻る</strong>。</p>
                    </div>
                </div>
            </div>
            <div class="mt-8">
                <h3 class="text-xl font-semibold mb-2">鏡の公式まとめ</h3>
                <div class="formula-box text-center text-lg">
                    <p>写像公式: $ \frac{1}{a} + \frac{1}{b} = \frac{1}{f} $　　倍率: $ m = -\frac{b}{a} $</p>
                </div>
                <p class="text-sm mt-2 text-gray-600">a: 物体距離, b: 像距離, f: 焦点距離 (凹面鏡は正, 凸面鏡は負)。bが正なら実像、負なら虚像。mが正なら正立像、負なら倒立像。</p>
            </div>
        </section>

        <section id="section-interference" class="section-card">
            <h2 class="text-3xl font-bold text-sky-700 mb-4">波の干渉（ヤングの実験）</h2>
            
            <div class="space-y-8 mb-12">
                <div>
                    <h3 class="text-2xl font-bold text-sky-600 mb-3 border-b-2 border-sky-200 pb-2">歴史：粒子か、波か</h3>
                    <div class="text-gray-700 space-y-4">
                        <p>17世紀から18世紀にかけて、科学界ではアイザック・ニュートンが提唱した光の「粒子説」が主流でした。光を微小な粒子の流れと考えるこの説は、光がまっすぐ進むこと（直進性）や反射をうまく説明できましたが、クリスティアーン・ホイヘンスらが提唱した「波動説」は、光がなぜ鮮明な影を作るのかを説明するのが難しく、影を潜めていました。</p>
                        <p>この状況を覆したのが、1807年のトーマス・ヤングによる二重スリット実験です。もし光が粒子なら、2つのスリットを通り抜けた光はスクリーン上に2本の明るい線を描くだけのはずです。しかし、ヤングが実際に観測したのは、明るい部分と暗い部分が交互に並ぶ「干渉縞」でした。このパターンは、波が強め合ったり（建設的干渉）、弱め合ったり（破壊的干渉）することでしか生まれない、波特有の現象だったのです。</p>
                    </div>
                </div>

                <div>
                    <h3 class="text-2xl font-bold text-sky-600 mb-3 border-b-2 border-sky-200 pb-2">数式とその説明</h3>
                    <div class="space-y-6">
                        <div>
                            <h4 class="text-xl font-semibold mb-2">経路差と干渉条件</h4>
                            <p class="text-gray-700 mb-4">ヤングの実験の鍵は、2つのスリット（S₁とS₂）からスクリーン上のある点（P）までの距離の差、つまり<strong class="text-sky-600">経路差</strong> $\Delta l = |S_2P - S_1P|$ です。この経路差が、光の波長 $\lambda$ の整数倍になるか、半整数倍になるかで、光が強め合うか弱め合うかが決まります。</p>
                            <div class="grid md:grid-cols-2 gap-4">
                                <div class="formula-box">
                                    <p class="font-bold text-center">明線の条件（強め合い）</p>
                                    <p class="text-center mt-2 text-lg">$\Delta l = m\lambda$</p>
                                    <p class="text-sm mt-1 text-center">($m = 0, 1, 2, \dots$)</p>
                                </div>
                                <div class="formula-box">
                                    <p class="font-bold text-center">暗線の条件（弱め合い）</p>
                                    <p class="text-center mt-2 text-lg">$\Delta l = (m + \frac{1}{2})\lambda$</p>
                                    <p class="text-sm mt-1 text-center">($m = 0, 1, 2, \dots$)</p>
                                </div>
                            </div>
                        </div>
                        
                        <div>
                            <h4 class="text-xl font-semibold mb-2">経路差の近似式</h4>
                            <p class="text-gray-700 mb-4">スクリーンからスリットまでの距離を $L$、スリットの間隔を $d$、スクリーン中心から測った距離を $x$ とします。実際の実験では、$L$ は $d$ や $x$ に比べて非常に大きい ($L \gg d, L \gg x$) ため、経路差 $\Delta l$ は以下の非常に便利な式で近似できます。</p>
                             <div class="formula-box text-center text-lg">
                                $\Delta l \approx \frac{dx}{L}$
                             </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="youngs-experiment-app">
                 <div class="container">
                    <h3 class="text-xl font-semibold mb-4 text-center">コントロールパネル</h3>
                    <div class="controls-panel">
                        <div class="control-group">
                            <label for="wavelength">光の波長 (λ): <span id="wavelengthValue">550</span> nm</label>
                            <input type="range" id="wavelength" min="400" max="700" value="550">
                        </div>
                        <div class="control-group">
                            <label for="slitSeparation">スリット間隔 (d): <span id="slitSeparationValue">0.25</span> mm</label>
                            <input type="range" id="slitSeparation" min="0.01" max="0.5" value="0.25" step="0.001">
                        </div>
                        <div class="control-group">
                            <label for="screenDistance">スクリーン距離 (L): <span id="screenDistanceValue">2.5</span> m</label>
                            <input type="range" id="screenDistance" min="0.5" max="5.0" value="2.5" step="0.1">
                        </div>
                    </div>
                </div>
                <div class="container">
                    <h3 class="text-xl font-semibold mb-4 text-center">波のアニメーション (マウスを乗せて経路差を確認)</h3>
                    <canvas id="waveCanvas" width="800" height="400"></canvas>
                </div>
                <div class="container">
                    <h3 class="text-xl font-semibold mb-4 text-center">干渉縞の強度分布グラフ</h3>
                    <canvas id="interferenceCanvas" width="800" height="200"></canvas>
                </div>
            </div>
        </section>

        <section id="section-diffraction-grating" class="section-card">
            <h2 class="text-3xl font-bold text-sky-700 mb-4">回折格子</h2>
            <p class="mb-6 text-gray-700">多数のスリットが等間隔に並んだ回折格子では、ヤングの実験よりもはるかに鋭く明るい干渉縞（明線）が生じます。この性質を利用して、光の成分を精密に分ける「分光器」などに利用されています。</p>
            
            <div class="grid md:grid-cols-2 gap-8 mb-6">
                <div class="formula-box text-center">
                    <p class="font-bold">回折格子の公式（明線条件）</p>
                    <p class="text-lg mt-2">$d \sin \theta = m\lambda$</p>
                    <p class="text-sm mt-1">$d$: 格子定数, $\theta$: 回折角, $m$: 次数 ($0, \pm1, \pm2 \dots$)</p>
                </div>
                 <div class="info-box text-sm flex items-center">
                    <p>💡 スリットの数が多いほど、明線は鋭くなり、波長ごとの分離能力が高まります。スリット間隔 $d$ が狭い（1mmあたりの本数が多い）ほど、光は大きく曲がります。</p>
                </div>
            </div>

            <div class="container">
                <canvas id="diffractionCanvas" width="800" height="350" class="animation-canvas w-full h-80"></canvas>
                <div class="controls-panel mt-6">
                    <div class="control-group">
                        <label for="diffractionWavelength">光の波長 (λ): <span id="diffractionWavelengthValue">550</span> nm</label>
                        <input type="range" id="diffractionWavelength" min="400" max="700" value="550">
                    </div>
                    <div class="control-group">
                        <label for="diffractionLinesMM">格子の本数 (N): <span id="diffractionLinesMMValue">300</span> 本/mm</label>
                        <input type="range" id="diffractionLinesMM" min="100" max="800" value="300" step="10">
                    </div>
                    <div class="control-group">
                        <label for="diffractionL">スクリーン距離 (L): <span id="diffractionLValue">1.0</span> m</label>
                        <input type="range" id="diffractionL" min="0.5" max="2.0" value="1.0" step="0.1">
                    </div>
                </div>
            </div>
        </section>

        <section id="section-thin-film" class="section-card">
            <h2 class="text-3xl font-bold text-sky-700 mb-4">薄膜の干渉</h2>
            <p class="mb-6 text-gray-700">シャボン玉や水面の油膜が色づいて見えるのは、膜の表面で反射した光と、裏面で反射した光が干渉するためです。膜の厚さによって強め合う波長（色）が変わります。</p>
            
            <div class="grid md:grid-cols-2 gap-8 mb-6">
                 <div class="formula-box text-center">
                    <p class="font-bold">強め合いの条件（空気中の膜）</p>
                    <p class="text-lg mt-2">$2nd = (m + \frac{1}{2})\lambda$</p>
                    <p class="text-sm mt-1">$n$: 屈折率, $d$: 膜の厚さ, $m=0,1,2\dots$<br>※表面での反射で位相が $\pi$ ずれるため</p>
                </div>
                <div class="info-box text-sm">
                    <p>ここでは、空気中にある薄膜（シャボン玉など）を想定しています。屈折率 $n>1$ の膜の表面（空気→膜）での反射では位相が反転し、裏面（膜→空気）での反射では位相は変わりません。</p>
                </div>
            </div>

            <div class="container">
                <canvas id="thinFilmCanvas" width="800" height="350" class="animation-canvas w-full h-80"></canvas>
                <div class="controls-panel mt-6">
                    <div class="control-group">
                        <label for="filmThickness">膜の厚さ (d): <span id="filmThicknessValue">400</span> nm</label>
                        <input type="range" id="filmThickness" min="100" max="1000" value="400" step="10">
                    </div>
                    <div class="control-group">
                        <label for="filmIndex">屈折率 (n): <span id="filmIndexValue">1.33</span></label>
                        <input type="range" id="filmIndex" min="1.0" max="2.0" value="1.33" step="0.01">
                    </div>
                    <div class="control-group">
                        <label for="filmWavelength">光の波長 (λ): <span id="filmWavelengthValue">550</span> nm</label>
                        <input type="range" id="filmWavelength" min="400" max="700" value="550">
                    </div>
                </div>
            </div>
        </section>

        <section id="section-newton-rings" class="section-card">
            <h2 class="text-3xl font-bold text-sky-700 mb-4">ニュートンリング</h2>
            <p class="mb-6 text-gray-700">曲率半径の大きい平凸レンズを平面ガラスの上に置くと、接触点を中心とした同心円状の干渉縞（ニュートンリング）が観察されます。レンズとガラスの間の空気層の厚さが変化することによって生じます。</p>
            
            <div class="grid md:grid-cols-2 gap-8 mb-6">
                <div class="formula-box text-center">
                    <p class="font-bold">暗環の条件（反射光）</p>
                    <p class="text-lg mt-2">$\frac{r^2}{R} = m\lambda$</p>
                     <p class="text-sm mt-1">$r$: リングの半径, $R$: レンズの曲率半径<br>※空気層の厚さ $t \approx \frac{r^2}{2R}$ なので $2t = m\lambda$</p>
                </div>
                <div class="info-box text-sm">
                    <p>中心（接触点）では空気層の厚さが0ですが、平面ガラス表面での反射で位相が $\pi$ ずれるため、光が打ち消し合って<strong>暗く</strong>なります。</p>
                </div>
            </div>

            <div class="container">
                <div class="flex flex-col md:flex-row gap-6 items-center">
                    <canvas id="newtonCanvas" width="300" height="300" class="animation-canvas bg-black flex-shrink-0" style="width:300px; height:300px;"></canvas>
                    <div class="flex-grow w-full">
                        <div class="controls-panel grid-cols-1 md:grid-cols-1">
                            <div class="control-group">
                                <label for="newtonR">レンズの曲率半径 (R): <span id="newtonRValue">5.0</span> m</label>
                                <input type="range" id="newtonR" min="1.0" max="10.0" value="5.0" step="0.1">
                            </div>
                            <div class="control-group">
                                <label for="newtonWavelength">光の波長 (λ): <span id="newtonWavelengthValue">550</span> nm</label>
                                <input type="range" id="newtonWavelength" min="400" max="700" value="550">
                            </div>
                        </div>
                        <div class="mt-4 p-4 bg-gray-50 rounded border">
                            <p class="font-bold mb-2">現在の干渉縞の状態:</p>
                            <p class="text-sm">中心は常に暗点です。外側に行くにつれて空気層が厚くなり、経路差が波長の整数倍になる場所で暗くなります。</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

    </main>

    <footer class="text-center py-6 bg-gray-100 mt-16">
        <p class="text-gray-500">インタラクティブ物理学習 | 光波の世界</p>
    </footer>

    <script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- Smooth Scrolling ---
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth' });
                }
            });
        });

        // --- 共通ヘルパー関数 ---
        const resizeCanvas = (canvas) => {
            if (!canvas) return false;
            const { width, height } = canvas.getBoundingClientRect();
            if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width;
                canvas.height = height;
                return true;
            }
            return false;
        };
        
        // 波長からRGB色を計算する関数
        const wavelengthToRgb = (wavelength) => {
            let r, g, b;
            if (wavelength >= 380 && wavelength <= 440) { r = -(wavelength - 440) / (440 - 380); g = 0.0; b = 1.0; } 
            else if (wavelength > 440 && wavelength <= 490) { r = 0.0; g = (wavelength - 440) / (490 - 440); b = 1.0; } 
            else if (wavelength > 490 && wavelength <= 510) { r = 0.0; g = 1.0; b = -(wavelength - 510) / (510 - 490); } 
            else if (wavelength > 510 && wavelength <= 580) { r = (wavelength - 510) / (580 - 510); g = 1.0; b = 0.0; } 
            else if (wavelength > 580 && wavelength <= 645) { r = 1.0; g = -(wavelength - 645) / (645 - 580); b = 0.0; } 
            else if (wavelength > 645 && wavelength <= 780) { r = 1.0; g = 0.0; b = 0.0; } 
            else { r = 0.0; g = 0.0; b = 0.0; }
            let factor = 1.0;
            if (wavelength > 700) { factor = 0.3 + 0.7 * (780 - wavelength) / (780 - 700); } 
            else if (wavelength < 420) { factor = 0.3 + 0.7 * (wavelength - 380) / (420 - 380); } 
            else { factor = 1.0; }
            return { r: Math.round(255 * (r * factor)), g: Math.round(255 * (g * factor)), b: Math.round(255 * (b * factor)) };
        };

        const drawArrow = (ctx, x, y_base, height, color, lineWidth, isDashed = false) => {
            if (!isFinite(height) || height === 0) return;
            const tipY = y_base - height;
            const wingOffset = height > 0 ? 7 : -7;
            ctx.beginPath();
            ctx.moveTo(x, y_base);
            ctx.lineTo(x, tipY);
            ctx.moveTo(x, tipY);
            ctx.lineTo(x - 5, tipY + wingOffset);
            ctx.moveTo(x, tipY);
            ctx.lineTo(x + 5, tipY + wingOffset);
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            if (isDashed) {
                ctx.setLineDash([4, 4]);
            }
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // --- ▼▼▼ 反射と屈折セクションのセットアップ ▼▼▼ ---
        const setupReflectionAndRefraction = () => {
            const snellCanvas = document.getElementById('snellCanvas');
            if (snellCanvas) {
                const ctx = snellCanvas.getContext('2d');
                const angleSlider = document.getElementById('snellAngle');
                const n2Slider = document.getElementById('snellN2');
                const angleValue = document.getElementById('snellAngleValue');
                const n2Value = document.getElementById('snellN2Value');
                const drawSnell = () => {
                    resizeCanvas(snellCanvas);
                    const w = snellCanvas.width, h = snellCanvas.height, i_deg = parseFloat(angleSlider.value), n1 = 1.0, n2 = parseFloat(n2Slider.value);
                    angleValue.textContent = i_deg.toFixed(0); n2Value.textContent = n2.toFixed(2);
                    const i_rad = i_deg * Math.PI / 180, sin_r = (n1 / n2) * Math.sin(i_rad);
                    let r_rad = Math.asin(sin_r);
                    ctx.clearRect(0, 0, w, h);
                    ctx.fillStyle = 'rgba(14, 165, 233, 0.1)'; ctx.fillRect(0, h/2, w, h/2);
                    ctx.fillStyle = '#0c4a6e'; ctx.fillText('媒質1 (n₁=1.0)', 10, 20); ctx.fillText(`媒質2 (n₂=${n2.toFixed(2)})`, 10, h - 10);
                    const originX = w/2, originY = h/2, rayLength = w/2;
                    ctx.beginPath(); ctx.setLineDash([5, 5]); ctx.moveTo(originX, 0); ctx.lineTo(originX, h); ctx.strokeStyle = '#9ca3af'; ctx.stroke(); ctx.setLineDash([]);
                    ctx.beginPath(); ctx.moveTo(0, originY); ctx.lineTo(w, originY); ctx.strokeStyle = '#374151'; ctx.lineWidth = 2; ctx.stroke();
                    const incidentX = originX - rayLength * Math.sin(i_rad), incidentY = originY - rayLength * Math.cos(i_rad);
                    ctx.beginPath(); ctx.moveTo(incidentX, incidentY); ctx.lineTo(originX, originY); ctx.strokeStyle = '#f97316'; ctx.lineWidth = 3; ctx.stroke();
                    const reflectedX = originX + rayLength * Math.sin(i_rad), reflectedY = originY - rayLength * Math.cos(i_rad);
                    ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(reflectedX, reflectedY); ctx.strokeStyle = '#fb923c'; ctx.lineWidth = 2; ctx.globalAlpha = 0.8; ctx.stroke(); ctx.globalAlpha = 1.0;
                    if (Math.abs(sin_r) <= 1) {
                        const refractedX = originX + rayLength * Math.sin(r_rad), refractedY = originY + rayLength * Math.cos(r_rad);
                        ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(refractedX, refractedY); ctx.strokeStyle = '#f97316'; ctx.lineWidth = 3; ctx.stroke();
                    }
                };
                angleSlider.addEventListener('input', drawSnell); n2Slider.addEventListener('input', drawSnell); 
                new ResizeObserver(drawSnell).observe(snellCanvas); drawSnell();
            }
            const tirCanvas = document.getElementById('totalInternalReflectionCanvas');
            if (tirCanvas) {
                const ctx = tirCanvas.getContext('2d');
                const angleSlider = document.getElementById('tirAngle');
                const angleValue = document.getElementById('tirAngleValue');
                const statusText = document.getElementById('tirStatus');
                const n1 = 1.5, n2 = 1.0, criticalAngleDeg = Math.asin(n2 / n1) * 180 / Math.PI;
                const drawTIR = () => {
                    resizeCanvas(tirCanvas);
                    const w = tirCanvas.width, h = tirCanvas.height, i_deg = parseFloat(angleSlider.value);
                    angleValue.textContent = i_deg.toFixed(0);
                    const i_rad = i_deg * Math.PI / 180;
                    ctx.clearRect(0, 0, w, h);
                    ctx.fillStyle = 'rgba(14, 165, 233, 0.1)'; ctx.fillRect(0, 0, w, h/2);
                    ctx.fillStyle = '#0c4a6e'; ctx.fillText(`媒質2 (空気, n₂=${n2.toFixed(1)})`, 10, 20); ctx.fillText(`媒質1 (ガラス, n₁=${n1.toFixed(1)})`, 10, h - 10);
                    const originX = w / 2, originY = h / 2, rayLength = w / 2;
                    ctx.beginPath(); ctx.setLineDash([5, 5]); ctx.moveTo(originX, 0); ctx.lineTo(originX, h); ctx.strokeStyle = '#9ca3af'; ctx.stroke(); ctx.setLineDash([]);
                    ctx.beginPath(); ctx.moveTo(0, originY); ctx.lineTo(w, originY); ctx.strokeStyle = '#374151'; ctx.lineWidth = 2; ctx.stroke();
                    const incidentX = originX - rayLength * Math.sin(i_rad), incidentY = originY + rayLength * Math.cos(i_rad);
                    ctx.beginPath(); ctx.moveTo(incidentX, incidentY); ctx.lineTo(originX, originY); ctx.strokeStyle = '#16a34a'; ctx.lineWidth = 3; ctx.stroke();
                    const reflectedX = originX + rayLength * Math.sin(i_rad), reflectedY = originY + rayLength * Math.cos(i_rad);
                    if (i_deg > criticalAngleDeg) {
                        statusText.textContent = '全反射'; statusText.className = 'font-bold text-lg mt-2 text-red-500';
                        ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(reflectedX, reflectedY); ctx.strokeStyle = '#16a34a'; ctx.lineWidth = 3; ctx.stroke();
                    } else {
                        statusText.textContent = '一部反射・一部屈折'; statusText.className = 'font-bold text-lg mt-2 text-blue-500';
                        ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(reflectedX, reflectedY); ctx.strokeStyle = '#4ade80'; ctx.lineWidth = 2; ctx.globalAlpha = 0.7; ctx.stroke(); ctx.globalAlpha = 1.0;
                        const sin_r = (n1 / n2) * Math.sin(i_rad), r_rad = Math.asin(sin_r);
                        const refractedX = originX + rayLength * Math.sin(r_rad), refractedY = originY - rayLength * Math.cos(r_rad);
                        ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(refractedX, refractedY); ctx.strokeStyle = '#16a34a'; ctx.lineWidth = 3; ctx.stroke();
                    }
                };
                angleSlider.addEventListener('input', drawTIR); 
                new ResizeObserver(drawTIR).observe(tirCanvas); drawTIR();
            }
            const mirageCanvas = document.getElementById('mirageCanvas');
            if(mirageCanvas) {
                const ctx = mirageCanvas.getContext('2d');
                let time = 0;
                let animationFrameId;
                const drawMirage = () => {
                    resizeCanvas(mirageCanvas);
                    const w = mirageCanvas.width, h = mirageCanvas.height;
                    ctx.clearRect(0, 0, w, h);
                    const sky = ctx.createLinearGradient(0, 0, 0, h); sky.addColorStop(0, '#87ceeb'); sky.addColorStop(1, '#f0f8ff');
                    ctx.fillStyle = sky; ctx.fillRect(0, 0, w, h);
                    ctx.fillStyle = '#d2b48c'; ctx.fillRect(0, h * 0.8, w, h * 0.2);
                    const treeX = w * 0.8, treeY = h * 0.8;
                    ctx.fillStyle = '#8B4513'; ctx.fillRect(treeX, treeY - 50, 10, 50);
                    ctx.fillStyle = '#008000'; ctx.beginPath(); ctx.arc(treeX + 5, treeY - 50, 25, Math.PI, 2 * Math.PI); ctx.fill();
                    ctx.save(); ctx.globalAlpha = 0.5; ctx.translate(treeX, treeY); ctx.scale(1, -1);
                    ctx.fillStyle = '#8B4513'; ctx.fillRect(0, -2, 10, 50);
                    ctx.fillStyle = '#008000'; ctx.beginPath(); ctx.arc(5, -50, 25, Math.PI, 2 * Math.PI); ctx.fill();
                    ctx.restore();
                    ctx.beginPath(); ctx.moveTo(treeX, treeY - 60);
                    ctx.quadraticCurveTo(w * 0.5, h * 0.8 + 10 + Math.sin(time) * 2, w * 0.1, h * 0.6);
                    ctx.strokeStyle = `rgba(255, 255, 100, ${0.5 + Math.sin(time * 1.5) * 0.2})`;
                    ctx.lineWidth = 2; ctx.setLineDash([3, 3]); ctx.stroke(); ctx.setLineDash([]);
                    ctx.fillStyle = 'black'; ctx.fillText('👁️', w * 0.1 - 15, h * 0.6 + 5);
                    time += 0.05; 
                    animationFrameId = requestAnimationFrame(drawMirage);
                };
                if (!window.mirageAnimationStarted) {
                    drawMirage();
                    window.mirageAnimationStarted = true;
                }
            }
        };

        // --- ▼▼▼ レンズと鏡のセクションのセットアップ ▼▼▼ ---
        const setupOpticsSimulations = () => {
            
            function calculateSystemProperties(f1, f2, d) {
                const combinedFocalLength = (f1 * f2) / (f1 + f2 - d);
                const h1_pos = (combinedFocalLength * d) / f2;
                const h2_pos = -(combinedFocalLength * d) / f1;
                return { combinedFocalLength, h1_pos, h2_pos };
            }

            function traceSystem(objectDist, objectHeight, f1, f2, d) {
                if (Math.abs(objectDist - f1) < 1e-6) return { finalImage: null, intermediateImage: null, totalMag: Infinity };
                const image1Dist = 1 / (1 / f1 - 1 / objectDist);
                const mag1 = -image1Dist / objectDist;
                const image1Height = objectHeight * mag1;
                const intermediateImage = { distance: image1Dist, height: image1Height };
                const object2Dist = d - image1Dist;
                if (Math.abs(object2Dist - f2) < 1e-6) return { finalImage: null, intermediateImage, totalMag: Infinity };
                const image2Dist = 1 / (1 / f2 - 1 / object2Dist);
                const mag2 = -image2Dist / object2Dist;
                const finalImageHeight = image1Height * mag2;
                const finalImage = { distance: image2Dist, height: finalImageHeight };
                const totalMag = mag1 * mag2;
                return { finalImage, intermediateImage, totalMag };
            }

            const drawLensShape = (ctx, x, y, height, f) => {
                 const bulge = 15; const topY = y - height/2, bottomY = y + height/2;
                 ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 2; ctx.fillStyle = 'rgba(191, 219, 254, 0.5)';
                 ctx.beginPath();
                 if (f > 0) {
                     ctx.moveTo(x, topY);
                     ctx.bezierCurveTo(x + bulge, topY + height/3, x + bulge, bottomY - height/3, x, bottomY);
                     ctx.bezierCurveTo(x - bulge, bottomY - height/3, x - bulge, topY + height/3, x, topY);
                 } else {
                     const edgeWidth = 12; const centerWidth = 4;
                     ctx.moveTo(x - edgeWidth, topY);
                     ctx.quadraticCurveTo(x - centerWidth, y, x - edgeWidth, bottomY);
                     ctx.lineTo(x + edgeWidth, bottomY);
                     ctx.quadraticCurveTo(x + centerWidth, y, x + edgeWidth, topY);
                     ctx.closePath();
                 }
                 ctx.closePath(); ctx.fill(); ctx.stroke();
            };
            
            const drawMirrorShape = (ctx, x, y_center, f, height) => {
                const R = 2 * f;
                const r_abs = Math.abs(R * 1.5);
                const angle = Math.asin(Math.min(1, height / (2 * r_abs)));
                ctx.strokeStyle = '#374151';
                ctx.lineWidth = 3;
                ctx.beginPath();
                if (f > 0) {
                    const centerX = x - r_abs;
                    ctx.arc(centerX, y_center, r_abs, -angle, angle);
                } else {
                    const centerX = x + r_abs;
                    ctx.arc(centerX, y_center, r_abs, Math.PI - angle, Math.PI + angle);
                }
                ctx.stroke();
            };

            const setupInteractiveOptic = (canvasId, distSliderId, heightSliderId, infoId, f, isMirror) => {
                const canvas = document.getElementById(canvasId);
                const distSlider = document.getElementById(distSliderId);
                const heightSlider = document.getElementById(heightSliderId);
                const infoDiv = document.getElementById(infoId);
                
                if (!canvas || !distSlider || !heightSlider || !infoDiv) return;

                const distValueSpan = distSlider.labels[0].querySelector('span');
                const heightValueSpan = heightSlider.labels[0].querySelector('span');
                const ctx = canvas.getContext('2d');
                
                let config = {
                    a: parseFloat(distSlider.value),
                    h: parseFloat(heightSlider.value)
                };

                let isDragging = false, dragStart = {x: 0, y:0}, initialConfig = {...config};

                const draw = () => {
                    resizeCanvas(canvas);
                    const w = canvas.width, h = canvas.height;
                    const scale = w / (isMirror ? 160 : 100);
                    const centerY = h / 2;
                    const opticX = isMirror ? w * 0.75 : w / 2;
                    const { a, h: objectHeight } = config;
                    
                    distValueSpan.textContent = a.toFixed(1);
                    heightValueSpan.textContent = objectHeight.toFixed(1);

                    let b, m;
                    if (Math.abs(a - f) < 0.1) { b = Infinity; m = Infinity; } 
                    else { b = 1 / (1 / f - 1 / a); m = -b / a; }

                    ctx.clearRect(0, 0, w, h);

                    const objectX = opticX - a * scale;
                    const imageX = isMirror ? opticX - b * scale : opticX + b * scale;
                    const imageHeight = objectHeight * m;
                    const rayStartY = centerY - objectHeight;
                    const imageTipY = centerY - imageHeight;
                    const focus1X = opticX - f * scale;
                    const focus2X = opticX + f * scale;
                    const centerX = opticX - 2 * f * scale;

                    ctx.beginPath(); ctx.moveTo(0, centerY); ctx.lineTo(w, centerY); ctx.strokeStyle = '#9ca3af'; ctx.lineWidth = 1; ctx.stroke();
                    isMirror ? drawMirrorShape(ctx, opticX, centerY, f, h * 0.9) : drawLensShape(ctx, opticX, centerY, h * 0.8, f);
                    
                    ctx.fillStyle = '#ef4444';
                    ctx.fillText(isMirror ? 'F' : 'F₁', focus1X - (isMirror ? 4 : 10), centerY - 10); ctx.beginPath(); ctx.arc(focus1X, centerY, 3, 0, 2*Math.PI); ctx.fill();
                    if(isMirror) {
                        ctx.fillText('C', centerX, centerY - 10); ctx.beginPath(); ctx.arc(centerX, centerY, 3, 0, 2*Math.PI); ctx.fill();
                    } else {
                        ctx.fillText('F₂', focus2X - 3, centerY - 10); ctx.beginPath(); ctx.arc(focus2X, centerY, 3, 0, 2*Math.PI); ctx.fill();
                    }

                    drawArrow(ctx, objectX, centerY, objectHeight, '#f97316', 3);
                    if (isFinite(b)) drawArrow(ctx, imageX, centerY, imageHeight, b > 0 ? '#16a34a' : '#6d28d9', 3, b < 0);
                    
                    ctx.lineWidth = 1.5; ctx.globalAlpha = 0.7;
                    
                    if(isMirror){
                        const objectTip = { x: objectX, y: rayStartY };
                        // ① 平行光
                        ctx.strokeStyle = '#3b82f6'; ctx.beginPath(); ctx.moveTo(objectTip.x, objectTip.y); ctx.lineTo(opticX, objectTip.y);
                        const slope1 = (objectTip.y - centerY) / (opticX - focus1X);
                        ctx.lineTo(isFinite(b) ? imageX : 0, isFinite(b) ? imageTipY : objectTip.y + slope1 * (0 - opticX));
                        ctx.stroke();
                        if (b < 0) { ctx.setLineDash([2,3]); ctx.beginPath(); ctx.moveTo(opticX, objectTip.y); ctx.lineTo(focus1X, centerY); ctx.stroke(); ctx.setLineDash([]); }

                        // ② 頂点
                        ctx.strokeStyle = '#16a34a'; ctx.beginPath(); ctx.moveTo(objectTip.x, objectTip.y); ctx.lineTo(opticX, centerY);
                        const slope2 = -(objectTip.y - centerY) / (opticX - objectTip.x);
                        ctx.lineTo(isFinite(b) ? imageX : 0, isFinite(b) ? imageTipY : centerY + slope2 * (0 - opticX));
                        ctx.stroke();
                        if (b < 0) { ctx.setLineDash([2,3]); ctx.beginPath(); ctx.moveTo(opticX, centerY); ctx.lineTo(imageX, imageTipY); ctx.stroke(); ctx.setLineDash([]); }
                        
                        // ③ 焦点
                        const slope3 = (objectTip.y - centerY) / (objectTip.x - focus1X);
                        const p3 = { x: opticX, y: centerY + slope3 * (opticX - focus1X) };
                        ctx.strokeStyle = '#8b5cf6'; ctx.beginPath(); ctx.moveTo(objectTip.x, objectTip.y); ctx.lineTo(p3.x, p3.y);
                        ctx.lineTo(isFinite(b) ? imageX : 0, isFinite(b) ? imageTipY : p3.y); ctx.stroke();
                        if (b < 0 || a < f) { ctx.setLineDash([2,3]); ctx.beginPath(); ctx.moveTo(objectTip.x, objectTip.y); ctx.lineTo(focus1X, centerY); ctx.stroke(); ctx.setLineDash([]); }

                        // ④ 中心
                        const slope4 = (objectTip.x - centerX) !== 0 ? (rayStartY - centerY) / (objectTip.x - centerX) : Infinity;
                        const p4 = { x: opticX, y: centerY + slope4 * (opticX - centerX) };
                        ctx.strokeStyle = '#f59e0b'; ctx.beginPath(); ctx.moveTo(objectTip.x, objectTip.y); ctx.lineTo(p4.x, p4.y); ctx.lineTo(objectTip.x, objectTip.y); ctx.stroke();
                        if (b < 0) { ctx.setLineDash([2,3]); ctx.beginPath(); ctx.moveTo(p4.x, p4.y); ctx.lineTo(imageX, imageTipY); ctx.stroke(); ctx.setLineDash([]); }
                    } else {
                        // レンズの作図ロジック
                        const objectTip = { x: objectX, y: rayStartY };
                        // Ray 1 (Parallel)
                        ctx.strokeStyle = '#d946ef'; ctx.beginPath(); ctx.moveTo(objectTip.x, objectTip.y); ctx.lineTo(opticX, objectTip.y);
                        if (f > 0) { // Convex
                           ctx.lineTo(isFinite(b) ? imageX : w, isFinite(b) ? imageTipY : rayStartY - (rayStartY-centerY)*(w-opticX)/(focus2X-opticX));
                        } else { // Concave
                           const slope = (objectTip.y - centerY) / (opticX - focus1X);
                           ctx.lineTo(0, objectTip.y + slope * (0 - opticX));
                        }
                        ctx.stroke();
                        if (b < 0) { ctx.setLineDash([2,3]); ctx.beginPath(); ctx.moveTo(opticX, objectTip.y); ctx.lineTo(imageX, imageTipY); ctx.stroke(); ctx.setLineDash([]); }

                        // Ray 2 (Center)
                        ctx.strokeStyle = '#22c55e'; ctx.beginPath(); ctx.moveTo(objectTip.x, objectTip.y); ctx.lineTo(opticX, centerY);
                        const slope2 = (objectTip.y - centerY) / (objectTip.x - opticX);
                        ctx.lineTo(isFinite(b) ? imageX : w, isFinite(b) ? imageTipY : centerY + slope2 * (w-opticX));
                        ctx.stroke();
                        if (b < 0) { ctx.setLineDash([2,3]); ctx.beginPath(); ctx.moveTo(opticX, centerY); ctx.lineTo(imageX, imageTipY); ctx.stroke(); ctx.setLineDash([]); }
                    }
                    
                    ctx.globalAlpha = 1.0;

                    let infoText = `像距離 b: ${isFinite(b)?b.toFixed(1):'∞'}, 倍率 m: ${isFinite(m)?m.toFixed(2):'∞'}`;
                    if (isFinite(b)) { infoText += `, 種類: ${b>0?'実像':'虚像'}, ${m<0?'倒立':'正立'}`; } 
                    else { infoText += ', 像は無限遠にできます'; }
                    infoDiv.innerHTML = infoText;
                };

                const update = (newConfig) => {
                    config = {...config, ...newConfig};
                    distSlider.value = config.a;
                    heightSlider.value = config.h;
                    draw();
                };

                distSlider.addEventListener('input', (e) => update({ a: parseFloat(e.target.value) }));
                heightSlider.addEventListener('input', (e) => update({ h: parseFloat(e.target.value) }));

                canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    const rect = canvas.getBoundingClientRect();
                    dragStart = { x: e.clientX - rect.left, y: e.clientY - rect.top };
                    initialConfig = { ...config };
                    canvas.style.cursor = 'grabbing';
                });
                window.addEventListener('mouseup', () => { isDragging = false; canvas.style.cursor = 'grab'; });
                canvas.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const rect = canvas.getBoundingClientRect();
                        const currentPos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
                        const dx = currentPos.x - dragStart.x;
                        const dy = currentPos.y - dragStart.y;
                        const scale = canvas.width / (isMirror ? 160 : 100);
                        const newA = Math.max(parseFloat(distSlider.min), Math.min(parseFloat(distSlider.max), initialConfig.a - dx / scale));
                        const newH = Math.max(parseFloat(heightSlider.min), Math.min(parseFloat(heightSlider.max), initialConfig.h - dy));
                        update({a: newA, h: newH});
                    }
                });

                new ResizeObserver(draw).observe(canvas);
                draw();
            };
            
            const setupCombinedLensSystem = () => {
                const canvas = document.getElementById('combinedLensCanvas');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                const sliders = { a1: document.getElementById('combinedObjectDistance'), h1: document.getElementById('combinedObjectHeight'), f1: document.getElementById('lens1FocalLength'), f2: document.getElementById('lens2FocalLength'), d: document.getElementById('lensSeparation') };
                const values = { a1: document.getElementById('combinedObjectDistanceValue'), h1: document.getElementById('combinedObjectHeightValue'), f1: document.getElementById('lens1FocalLengthValue'), f2: document.getElementById('lens2FocalLengthValue'), d: document.getElementById('lensSeparationValue') };
                const infoDiv = document.getElementById('combinedLensInfo');
                const advancedInfoDiv = document.getElementById('combinedLensAdvancedInfo');
                let config = { object: { distance: 150, height: 20 }, lens1: { focalLength: 100 }, lens2: { focalLength: 120 }, separation: 250, };
                let isDragging = false, dragStartX = 0, initialObjectDistance = config.object.distance;

                const draw = () => {
                    resizeCanvas(canvas);
                    const w = canvas.width, h = canvas.height, scale = w / 600, centerY = h / 2;
                    const { object, lens1, lens2, separation } = config;
                    values.a1.textContent = object.distance.toFixed(1); values.h1.textContent = object.height.toFixed(1);
                    values.f1.textContent = lens1.focalLength.toFixed(1); values.f2.textContent = lens2.focalLength.toFixed(1); values.d.textContent = separation.toFixed(1);
                    const traceResult = traceSystem(object.distance, object.height, lens1.focalLength, lens2.focalLength, separation);
                    const systemProps = calculateSystemProperties(lens1.focalLength, lens2.focalLength, separation);
                    const { finalImage, intermediateImage, totalMag } = traceResult;
                    ctx.clearRect(0, 0, w, h);
                    const lens1X = w / 2 - (separation / 2) * scale, lens2X = w / 2 + (separation / 2) * scale;
                    const objectX = lens1X - object.distance * scale, rayStartY = centerY - object.height * scale;
                    const intermediateImageX = intermediateImage ? lens1X + intermediateImage.distance * scale : NaN;
                    const intermediateImageY = intermediateImage ? centerY - intermediateImage.height * scale : NaN;
                    const finalImageX = finalImage ? lens2X + finalImage.distance * scale : NaN;
                    const finalImageY = finalImage ? centerY - finalImage.height * scale : NaN;
                    ctx.beginPath(); ctx.moveTo(0, centerY); ctx.lineTo(w, centerY); ctx.strokeStyle = '#9ca3af'; ctx.lineWidth = 1; ctx.setLineDash([2, 2]); ctx.stroke(); ctx.setLineDash([]);
                    drawLensShape(ctx, lens1X, centerY, h * 0.9, lens1.focalLength);
                    drawLensShape(ctx, lens2X, centerY, h * 0.9, lens2.focalLength);
                    ctx.fillStyle = '#ef4444';
                    const f1_x = lens1X - lens1.focalLength * scale, f1_prime_x = lens1X + lens1.focalLength * scale;
                    const f2_x = lens2X - lens2.focalLength * scale, f2_prime_x = lens2X + lens2.focalLength * scale;
                    ctx.fillText("F₁", f1_x - 10, centerY - 10); ctx.beginPath(); ctx.arc(f1_x, centerY, 3, 0, 2*Math.PI); ctx.fill();
                    ctx.fillText("F₁'", f1_prime_x - 5, centerY - 10); ctx.beginPath(); ctx.arc(f1_prime_x, centerY, 3, 0, 2*Math.PI); ctx.fill();
                    ctx.fillText("F₂", f2_x - 10, centerY - 10); ctx.beginPath(); ctx.arc(f2_x, centerY, 3, 0, 2*Math.PI); ctx.fill();
                    ctx.fillText("F₂'", f2_prime_x - 5, centerY - 10); ctx.beginPath(); ctx.arc(f2_prime_x, centerY, 3, 0, 2*Math.PI); ctx.fill();
                    drawArrow(ctx, objectX, centerY, object.height * scale, '#f97316', 3);
                    if (intermediateImage) { drawArrow(ctx, intermediateImageX, centerY, intermediateImage.height * scale, '#fb923c', 2, true); }
                    if (finalImage) { drawArrow(ctx, finalImageX, centerY, finalImage.height * scale, totalMag < 0 ? '#16a34a' : '#6d28d9', 3, finalImage.distance < 0); }
                    ctx.lineWidth = 1; ctx.globalAlpha = 0.7;
                    ctx.strokeStyle = '#d946ef'; ctx.beginPath(); ctx.moveTo(objectX, rayStartY); ctx.lineTo(lens1X, rayStartY);
                    if (isFinite(intermediateImageX)) {
                        const yAtLens2 = rayStartY + (lens2X - lens1X) * (intermediateImageY - rayStartY) / (intermediateImageX - lens1X);
                        ctx.lineTo(lens2X, yAtLens2);
                        if (isFinite(finalImageX)) { ctx.lineTo(finalImageX, finalImageY); } 
                        else { const slope = (yAtLens2 - centerY) / (lens2X - f2_x); ctx.lineTo(w, yAtLens2 + slope * (w-lens2X)); }
                    } else { ctx.lineTo(w, rayStartY); }
                    ctx.stroke();
                    ctx.strokeStyle = '#22c55e'; ctx.beginPath(); ctx.moveTo(objectX, rayStartY);
                    if (isFinite(intermediateImageX)) {
                        const yAtLens2 = centerY + (lens2X-lens1X)*(intermediateImageY-centerY)/(intermediateImageX-lens1X);
                        ctx.lineTo(lens2X, yAtLens2);
                        if (isFinite(finalImageX)) { ctx.lineTo(finalImageX, finalImageY); }
                        else { const slope = (yAtLens2-centerY)/(lens2X-f2_x); ctx.lineTo(w, yAtLens2+slope*(w-lens2X)); }
                    } else { const slope = (rayStartY-centerY)/(objectX - lens1X); ctx.lineTo(w, centerY + slope * (w-lens1X)); }
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;
                    const formatNum = (n) => isFinite(n) ? n.toFixed(1) : '∞';
                    infoDiv.innerHTML = `中間像 b₁: ${formatNum(intermediateImage?.distance)}, m₁: ${formatNum(intermediateImage ? -intermediateImage.distance/object.distance : Infinity)} | 物体 a₂: ${formatNum(intermediateImage ? separation - intermediateImage.distance : '∞')}<br>最終像 b₂: ${formatNum(finalImage?.distance)}, 総合倍率 M: ${formatNum(totalMag)}`;
                    advancedInfoDiv.innerHTML = `合成焦点距離 f: ${formatNum(systemProps.combinedFocalLength)} | 主平面H₁ (L₁から): ${formatNum(systemProps.h1_pos)}, H₂ (L₂から): ${formatNum(systemProps.h2_pos)}`;
                };
                const updateConfig = (key, value) => {
                     const newConfig = { ...config }; const keys = key.split('.');
                     if (keys.length === 2) { newConfig[keys[0]][keys[1]] = value; } else { newConfig[keys[0]] = value; }
                     config = newConfig; 
                     const sliderKeyMap = { 'object.distance': 'a1', 'object.height': 'h1', 'lens1.focalLength': 'f1', 'lens2.focalLength': 'f2', 'separation': 'd' };
                     const sliderKey = sliderKeyMap[key] || key;
                     if(sliders[sliderKey]) sliders[sliderKey].value = value;
                     draw();
                };
                for (const key in sliders) {
                    const fullKey = key === 'a1' ? 'object.distance' : key === 'h1' ? 'object.height' : key === 'f1' ? 'lens1.focalLength' : key === 'f2' ? 'lens2.focalLength' : 'separation';
                    sliders[key].addEventListener('input', (e) => updateConfig(fullKey, parseFloat(e.target.value)));
                }
                canvas.addEventListener('mousedown', (e) => { isDragging = true; dragStartX = e.clientX; initialObjectDistance = config.object.distance; canvas.style.cursor = 'grabbing'; });
                window.addEventListener('mouseup', () => { isDragging = false; canvas.style.cursor = 'grab'; });
                window.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const dx = e.clientX - dragStartX; const scale = canvas.width / 600; const newDist = initialObjectDistance - (dx / scale);
                        if (newDist > 0) { updateConfig('object.distance', newDist); }
                    }
                });
                new ResizeObserver(draw).observe(canvas);
                Object.values(sliders).forEach(s => { if(s) s.dispatchEvent(new Event('input')); });
                draw();
            }
            
            setupInteractiveOptic('convexLensCanvas', 'convexObjectDistance', 'convexObjectHeight', 'convexLensInfo', 15, false);
            setupInteractiveOptic('concaveLensCanvas', 'concaveObjectDistance', 'concaveObjectHeight', 'concaveLensInfo', -15, false);
            setupInteractiveOptic('concaveMirrorCanvas', 'concaveMirrorObjectDistance', 'concaveMirrorObjectHeight', 'concaveMirrorInfo', 20, true);
            setupInteractiveOptic('convexMirrorCanvas', 'convexMirrorObjectDistance', 'convexMirrorObjectHeight', 'convexMirrorInfo', -20, true);
            setupCombinedLensSystem();
        };

        const setupYoungsExperiment = () => {
       	    const waveCanvas = document.getElementById('waveCanvas');
            if (!waveCanvas) return;
	    const waveCtx = waveCanvas.getContext('2d');
	    const interferenceCanvas = document.getElementById('interferenceCanvas');
	    const interferenceCtx = interferenceCanvas.getContext('2d');
	    
	    const wavelengthSlider = document.getElementById('wavelength');
	    const slitSeparationSlider = document.getElementById('slitSeparation');
	    const screenDistanceSlider = document.getElementById('screenDistance');
	    
	    const wavelengthValue = document.getElementById('wavelengthValue');
	    const slitSeparationValue = document.getElementById('slitSeparationValue');
	    const screenDistanceValue = document.getElementById('screenDistanceValue');

	    let params = {};
	    let scale = {};
	    let t = 0;
	    let animationId;
	    let mousePos = null;
	    let screenX = 0;
	    const waveSpeed = 0.25;
	    
	    function setup() {
		updateParams();
		addEventListeners();
		startAnimation();
	    }
	    function updateParams() {
		params.lambda = parseFloat(wavelengthSlider.value);
		params.d = parseFloat(slitSeparationSlider.value);
		params.L = parseFloat(screenDistanceSlider.value);
        
		const physicalWidthMM = 5; 
		scale.pxPerMM = waveCanvas.width / physicalWidthMM;
		scale.mmPerPx = physicalWidthMM / waveCanvas.width;
		
		wavelengthValue.textContent = params.lambda.toFixed(0);
		slitSeparationValue.textContent = params.d.toFixed(3);
		screenDistanceValue.textContent = params.L.toFixed(1);

		const minL = 0.5, maxL = 5.0;
		const minScreenX = waveCanvas.width * 0.25;
		const maxScreenX = waveCanvas.width * 0.95;
		screenX = minScreenX + ((params.L - minL) / (maxL - minL)) * (maxScreenX - minScreenX);
        
		const color = wavelengthToRgb(params.lambda);
		const thumbStyle = `
            input[type="range"]#wavelength::-webkit-slider-thumb { background: rgb(${color.r}, ${color.g}, ${color.b}); }
            input[type="range"]#wavelength::-moz-range-thumb { background: rgb(${color.r}, ${color.g}, ${color.b}); }
        `;
		let styleSheet = document.getElementById('slider-color-style');
		if (!styleSheet) {
		    styleSheet = document.createElement('style');
		    styleSheet.id = 'slider-color-style';
		    document.head.appendChild(styleSheet);
		}
		styleSheet.textContent = thumbStyle;
	    }

	    function addEventListeners() {
		[wavelengthSlider, slitSeparationSlider, screenDistanceSlider].forEach(slider => {
		    slider.addEventListener('input', updateParams);
		});
		
		waveCanvas.addEventListener('mousemove', e => {
		    const rect = waveCanvas.getBoundingClientRect();
		    mousePos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
		});
		waveCanvas.addEventListener('mouseleave', () => { mousePos = null; });
	    }

	    function animate() {
		t += 1;
		drawWaves();
		drawInterferenceGraph();
		if (mousePos) {
		    drawPathDifference(mousePos.x, mousePos.y);
		}
		animationId = requestAnimationFrame(animate);
	    }
    
	    function startAnimation() {
		if (animationId) cancelAnimationFrame(animationId);
		animate();
	    }
    
	    function drawWaves() {
		const width = waveCanvas.width;
		const height = waveCanvas.height;

		waveCtx.fillStyle = 'black';
		waveCtx.fillRect(0, 0, width, height);

		const slitYCenter = height / 2;
		const slitX = width * 0.1;
		const slitSeparationPx = params.d * scale.pxPerMM;
		const s1 = { x: slitX, y: slitYCenter - slitSeparationPx / 2 };
		const s2 = { x: slitX, y: slitYCenter + slitSeparationPx / 2 };
        
		const base_lambda_px = 10;
		const visual_lambda_px = base_lambda_px * (params.lambda / 400.0);
		const color = wavelengthToRgb(params.lambda);
		waveCtx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.8)`;
		waveCtx.lineWidth = 2;

		const maxRadius = width;
		const phaseOffset = (t * waveSpeed) % visual_lambda_px;

		[s1, s2].forEach(slit => {
		    for (let r = phaseOffset; r < maxRadius; r += visual_lambda_px) {
			waveCtx.beginPath();
			waveCtx.arc(slit.x, slit.y, r, 0, 2 * Math.PI);
			waveCtx.stroke();
		    }
		});

		const slitVisualWidthPx = 12;
		waveCtx.strokeStyle = 'rgba(200, 200, 200, 0.9)';
		waveCtx.lineWidth = 4;
        
		waveCtx.beginPath();
		waveCtx.moveTo(slitX, 0);
		waveCtx.lineTo(slitX, s1.y - slitVisualWidthPx / 2);
		waveCtx.moveTo(slitX, s1.y + slitVisualWidthPx / 2);
		waveCtx.lineTo(slitX, s2.y - slitVisualWidthPx / 2);
		waveCtx.moveTo(slitX, s2.y + slitVisualWidthPx / 2);
		waveCtx.lineTo(slitX, height);
		waveCtx.stroke();
	
		waveCtx.fillStyle = "white";
		waveCtx.beginPath();
		waveCtx.arc(s1.x, s1.y, 4, 0, 2 * Math.PI);
		waveCtx.arc(s2.x, s2.y, 4, 0, 2 * Math.PI);
		waveCtx.fill();
        
		for (let y_px = 0; y_px < height; y_px++) {
		    const dx1 = screenX - s1.x, dy1 = y_px - s1.y;
		    const dx2 = screenX - s2.x, dy2 = y_px - s2.y;
		    const r1_px = Math.sqrt(dx1*dx1 + dy1*dy1);
		    const r2_px = Math.sqrt(dx2*dx2 + dy2*dy2);
		    const pathDiff_px = Math.abs(r1_px - r2_px);
		    const phaseDiff_visual = (2 * Math.PI * pathDiff_px) / visual_lambda_px;
		    const intensity = Math.pow(Math.cos(phaseDiff_visual / 2), 2);
		    waveCtx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${intensity})`;
		    waveCtx.fillRect(screenX, y_px, 50, 1);
		}
        
		waveCtx.beginPath();
		waveCtx.moveTo(screenX, 0);
		waveCtx.lineTo(screenX, height);
		waveCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
		waveCtx.lineWidth = 4;
		waveCtx.setLineDash([6, 6]);
		waveCtx.stroke();
		waveCtx.setLineDash([]);
        
		waveCtx.save();
		waveCtx.translate(screenX - 15, height / 2); 
		waveCtx.rotate(-Math.PI / 2);
		waveCtx.font = 'bold 14px "Noto Sans JP", sans-serif';
		waveCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
		waveCtx.textAlign = 'center';
		waveCtx.fillText('スクリーン (Screen)', 0, 0);
		waveCtx.restore();
        
		const arrowY = height - 20;
		waveCtx.beginPath();
		waveCtx.moveTo(slitX, arrowY);
		waveCtx.lineTo(screenX, arrowY);
		waveCtx.moveTo(slitX + 5, arrowY - 5); waveCtx.lineTo(slitX, arrowY); waveCtx.lineTo(slitX + 5, arrowY + 5);
		waveCtx.moveTo(screenX - 5, arrowY - 5); waveCtx.lineTo(screenX, arrowY); waveCtx.lineTo(screenX - 5, arrowY + 5);
		waveCtx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
		waveCtx.lineWidth = 1.5;
		waveCtx.stroke();
		waveCtx.font = '14px "Noto Sans JP", sans-serif';
		waveCtx.fillStyle = 'white';
		waveCtx.textAlign = 'center';
		waveCtx.fillText(`L = ${params.L.toFixed(1)} m (模式図)`, (slitX + screenX) / 2, arrowY - 10);
	    }

	    function drawInterferenceGraph() {
		const graphWidth = interferenceCanvas.width;
		const graphHeight = interferenceCanvas.height;
		interferenceCtx.clearRect(0, 0, graphWidth, graphHeight);

		interferenceCtx.beginPath();
		for (let i = 0; i <= 10; i++) {
		    const y = (i / 10) * graphHeight;
		    interferenceCtx.moveTo(0, y);
		    interferenceCtx.lineTo(graphWidth, y);
		}
		for (let i = 0; i <= 20; i++) {
		    const x = (i / 20) * graphWidth;
		    interferenceCtx.moveTo(x, 0);
		    interferenceCtx.lineTo(x, graphHeight);
		}
		interferenceCtx.strokeStyle = '#e0e0e0';
		interferenceCtx.lineWidth = 0.5;
		interferenceCtx.stroke();

		const waveWidth = waveCanvas.width;
		const waveHeight = waveCanvas.height;
		
		const slitYCenter = waveHeight / 2;
		const slitX = waveWidth * 0.1;
		const slitSeparationPx = params.d * scale.pxPerMM;
		const s1 = { x: slitX, y: slitYCenter - slitSeparationPx / 2 };
		const s2 = { x: slitX, y: slitYCenter + slitSeparationPx / 2 };
        
		const base_lambda_px = 15;
		const visual_lambda_px = base_lambda_px * (params.lambda / 400.0);
		const color = wavelengthToRgb(params.lambda);

		interferenceCtx.beginPath();
		interferenceCtx.moveTo(0, graphHeight);

		for (let i = 0; i < graphWidth; i++) {
		    const rangeMultiplier = 2.5;
		    const y_center = waveHeight / 2;
		    const totalRange = waveHeight * rangeMultiplier;
		    const y_px = y_center - (totalRange / 2) + (i / graphWidth) * totalRange;
            
		    const dx1 = screenX - s1.x, dy1 = y_px - s1.y;
		    const dx2 = screenX - s2.x, dy2 = y_px - s2.y;
		    const r1_px = Math.sqrt(dx1*dx1 + dy1*dy1);
		    const r2_px = Math.sqrt(dx2*dx2 + dy2*dy2);
		    const pathDiff_px = Math.abs(r1_px - r2_px);
		    const phaseDiff_visual = (2 * Math.PI * pathDiff_px) / visual_lambda_px;
		    const interferenceEffect = Math.pow(Math.cos(phaseDiff_visual / 2), 2);

		    const slitWidthPx = (params.d * scale.pxPerMM) * 0.2;
		    const theta = Math.atan2(y_px - waveHeight / 2, screenX - slitX);
		    const beta = (Math.PI * slitWidthPx * Math.sin(theta)) / visual_lambda_px;
            
		    let diffractionEffect = 1.0;
		    if (Math.abs(beta) > 1e-6) {
			diffractionEffect = Math.pow(Math.sin(beta) / beta, 2);
		    }
            
		    const intensity = interferenceEffect * diffractionEffect;
		    
		    const y_graph = (1 - intensity) * graphHeight * 0.9 + graphHeight * 0.05;
		    interferenceCtx.lineTo(i, y_graph);
		}
        
		interferenceCtx.strokeStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
		interferenceCtx.lineWidth = 3;
		interferenceCtx.stroke();
		
		interferenceCtx.fillStyle = '#333';
		interferenceCtx.font = '12px sans-serif';
		interferenceCtx.textAlign = 'center';
        
		const screenPhysicalHeightMM = 40; 
		for (let mm = -20; mm <= 20; mm += 10) {
		    const pixelX = (mm + screenPhysicalHeightMM / 2) / screenPhysicalHeightMM * graphWidth;
		    
		    interferenceCtx.beginPath();
		    interferenceCtx.moveTo(pixelX, graphHeight * 0.95);
		    interferenceCtx.lineTo(pixelX, graphHeight);
		    interferenceCtx.strokeStyle = '#ccc';
		    interferenceCtx.lineWidth = 1;
		    interferenceCtx.stroke();
		    interferenceCtx.fillText(mm.toString(), pixelX, graphHeight - 15);
		}
		interferenceCtx.textAlign = 'right';
		interferenceCtx.fillText("(mm)", graphWidth - 5, graphHeight - 5);
	    }            

	    function drawPathDifference(targetX, targetY) {
		const slitYCenter = waveCanvas.height / 2;
		const slitX = waveCanvas.width * 0.1;
		const slitSeparationPx = params.d * scale.pxPerMM;
		const s1 = { x: slitX, y: slitYCenter - slitSeparationPx / 2 };
		const s2 = { x: slitX, y: slitYCenter + slitSeparationPx / 2 };
		waveCtx.beginPath();
		waveCtx.arc(targetX, targetY, 5, 0, 2 * Math.PI);
		waveCtx.fillStyle = 'rgba(255, 255, 0, 0.8)';
		waveCtx.fill();
		waveCtx.beginPath();
		waveCtx.moveTo(s1.x, s1.y); waveCtx.lineTo(targetX, targetY);
		waveCtx.moveTo(s2.x, s2.y); waveCtx.lineTo(targetX, targetY);
		waveCtx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
		waveCtx.lineWidth = 1.5;
		waveCtx.stroke();
		const dx1 = targetX - s1.x, dy1 = targetY - s1.y;
		const dx2 = targetX - s2.x, dy2 = targetY - s2.y;
		const r1_px = Math.sqrt(dx1 * dx1 + dy1 * dy1);
		const r2_px = Math.sqrt(dx2 * dx2 + dy2 * dy2);
		const base_lambda_px = 15;
		const visual_lambda_px = base_lambda_px * (params.lambda / 400.0);
		const pathDiff_px = Math.abs(r1_px - r2_px);
		const pathDiffInWavelengths = pathDiff_px / visual_lambda_px;
		
        const phaseDiff_visual = (2 * Math.PI * pathDiff_px) / visual_lambda_px;
        const intensity = Math.pow(Math.cos(phaseDiff_visual / 2), 2);

		let conditionText = '';
		if (intensity > 0.8) {
		    conditionText = `強め合い (明るい縞)`;
		} else if (intensity < 0.2) {
		    conditionText = `弱め合い (暗い縞)`;
		}

		waveCtx.font = 'bold 14px "Noto Sans JP", sans-serif';
		waveCtx.fillStyle = 'white';
		waveCtx.shadowColor = 'black'; waveCtx.shadowBlur = 4;
		const text1 = `経路差: 波長の${pathDiffInWavelengths.toFixed(2)}倍`;
		waveCtx.fillText(text1, targetX + 15, targetY - 10);
		if (conditionText) {
		    waveCtx.fillStyle = (conditionText.includes('強め')) ? '#86E3CE' : '#FFC0CB';
		    waveCtx.fillText(conditionText, targetX + 15, targetY + 10);
		}
		waveCtx.shadowBlur = 0;
	    }
            setup();
        };

        // --- 追加セクション: 回折格子 ---
        const setupDiffraction = () => {
            const canvas = document.getElementById('diffractionCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const lambdaSlider = document.getElementById('diffractionWavelength');
            const linesSlider = document.getElementById('diffractionLinesMM');
            const LSlider = document.getElementById('diffractionL');
            const valLambda = document.getElementById('diffractionWavelengthValue');
            const valLines = document.getElementById('diffractionLinesMMValue');
            const valL = document.getElementById('diffractionLValue');

            const draw = () => {
                resizeCanvas(canvas);
                const w = canvas.width, h = canvas.height;
                const lambda = parseFloat(lambdaSlider.value) * 1e-9; // m
                const N = parseFloat(linesSlider.value) * 1e3; // lines/m
                const d = 1 / N; // m
                const L = parseFloat(LSlider.value); // m
                
                valLambda.textContent = (lambda * 1e9).toFixed(0);
                valLines.textContent = (N / 1e3).toFixed(0);
                valL.textContent = L.toFixed(1);

                ctx.clearRect(0, 0, w, h);
                const color = wavelengthToRgb(lambda * 1e9);
                const rgb = `rgb(${color.r}, ${color.g}, ${color.b})`;

                // 描画設定
                const centerX = w / 2;
                const gratingY = h - 50;
                const screenY = 50;
                
                // 格子を描画
                ctx.strokeStyle = '#666';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(centerX - 100, gratingY);
                ctx.lineTo(centerX + 100, gratingY);
                ctx.stroke();
                // スリットのイメージ
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                for(let i=-10; i<=10; i++) {
                    ctx.beginPath();
                    ctx.moveTo(centerX + i * 8, gratingY - 2);
                    ctx.lineTo(centerX + i * 8, gratingY + 2);
                    ctx.stroke();
                }

                // スクリーンを描画
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(20, screenY);
                ctx.lineTo(w - 20, screenY);
                ctx.stroke();

                // 明線の計算と描画
                // d sin(theta) = m * lambda
                const maxOrder = Math.floor(d / lambda);
                
                // 光線の描画
                ctx.globalAlpha = 0.6;
                ctx.strokeStyle = rgb;
                
                for (let m = -maxOrder; m <= maxOrder; m++) {
                    if (m === 0) {
                        ctx.lineWidth = 4;
                    } else {
                        ctx.lineWidth = 2;
                    }

                    const sinTheta = (m * lambda) / d;
                    // スクリーン上の位置 x = L * tan(theta)
                    // スケール変換: 画面幅いっぱいを 2m (±1m) 程度とする簡易スケーリング
                    // しかし、Lが変わると視野角が変わるべきだが、ここではスクリーン上の物理位置を表示
                    // 画面上のスクリーン幅を物理的な 1.0m と仮定してみる
                    const screenPhysicalWidth = 1.0; // m
                    const theta = Math.asin(sinTheta);
                    const tanTheta = Math.tan(theta);
                    const x_physical = L * tanTheta;
                    
                    // 画面上のX座標 (中心が0)
                    const scaleFactor = (w - 100) / screenPhysicalWidth; 
                    const x_screen = centerX + x_physical * scaleFactor;

                    if (x_screen >= 20 && x_screen <= w - 20) {
                        // 光線
                        ctx.beginPath();
                        ctx.moveTo(centerX, gratingY);
                        ctx.lineTo(x_screen, screenY);
                        ctx.stroke();

                        // 明線スポット
                        ctx.fillStyle = rgb;
                        ctx.beginPath();
                        ctx.arc(x_screen, screenY, m===0 ? 6 : 4, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // 次数ラベル
                        ctx.fillStyle = '#333';
                        ctx.font = '12px sans-serif';
                        ctx.fillText(`m=${m}`, x_screen - 10, screenY - 15);
                    }
                }
                ctx.globalAlpha = 1.0;
            };

            lambdaSlider.addEventListener('input', draw);
            linesSlider.addEventListener('input', draw);
            LSlider.addEventListener('input', draw);
            new ResizeObserver(draw).observe(canvas);
            draw();
        };

        // --- 追加セクション: 薄膜 ---
        const setupThinFilm = () => {
            const canvas = document.getElementById('thinFilmCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const dSlider = document.getElementById('filmThickness');
            const nSlider = document.getElementById('filmIndex');
            const lSlider = document.getElementById('filmWavelength');
            const valD = document.getElementById('filmThicknessValue');
            const valN = document.getElementById('filmIndexValue');
            const valL = document.getElementById('filmWavelengthValue');

            const draw = () => {
                resizeCanvas(canvas);
                const w = canvas.width, h = canvas.height;
                const d = parseFloat(dSlider.value); // nm
                const n = parseFloat(nSlider.value);
                const lambda = parseFloat(lSlider.value); // nm

                valD.textContent = d;
                valN.textContent = n.toFixed(2);
                valL.textContent = lambda;

                ctx.clearRect(0, 0, w, h);

                // 膜の描画
                const filmTopY = 100;
                const filmBottomY = filmTopY + (d / 5); // 厚さを視覚的にスケーリング (5で割る)
                
                // 空気 (上)
                ctx.fillStyle = '#f0f9ff';
                ctx.fillRect(0, 0, w, filmTopY);
                // 膜
                ctx.fillStyle = `rgba(200, 230, 255, ${0.3 + (n-1)*0.5})`; // 屈折率で濃さを変える
                ctx.fillRect(0, filmTopY, w, filmBottomY - filmTopY);
                ctx.strokeStyle = '#999';
                ctx.beginPath(); ctx.moveTo(0, filmTopY); ctx.lineTo(w, filmTopY); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(0, filmBottomY); ctx.lineTo(w, filmBottomY); ctx.stroke();
                ctx.fillStyle = '#666';
                ctx.fillText('空気 (n=1.0)', 10, filmTopY - 10);
                ctx.fillText(`薄膜 (n=${n.toFixed(2)}, d=${d}nm)`, 10, filmTopY + 25);
                ctx.fillText('空気 (n=1.0)', 10, filmBottomY + 20);

                // 光路差と干渉計算 (垂直入射近似)
                // 経路差 = 2nd
                // 位相差 delta = (2*pi / lambda) * 2nd + pi (表面反射でpiずれる)
                // 強度 I = cos^2(delta / 2)
                const pathDiff = 2 * n * d;
                const phaseDiff = (2 * Math.PI * pathDiff) / lambda + Math.PI;
                const intensity = Math.pow(Math.cos(phaseDiff / 2), 2);

                // 光線の描画 (模式図として少し斜めに入射させる)
                const originX = w / 3;
                const shiftX = 60; 
                const rayColor = wavelengthToRgb(lambda);
                const colorStr = `rgb(${rayColor.r}, ${rayColor.g}, ${rayColor.b})`;
                
                ctx.lineWidth = 3;
                
                // 入射光
                ctx.strokeStyle = colorStr;
                ctx.beginPath();
                ctx.moveTo(originX - 50, 0);
                ctx.lineTo(originX, filmTopY);
                ctx.stroke();
                drawArrow(ctx, originX - 25, 50, 10, colorStr, 3); // 矢印

                // 表面反射光 (Ray 1)
                ctx.strokeStyle = `rgba(${rayColor.r}, ${rayColor.g}, ${rayColor.b}, 0.8)`;
                ctx.beginPath();
                ctx.moveTo(originX, filmTopY);
                ctx.lineTo(originX + 50, 0);
                ctx.stroke();

                // 屈折・裏面反射光 (Ray 2)
                ctx.strokeStyle = `rgba(${rayColor.r}, ${rayColor.g}, ${rayColor.b}, 0.6)`;
                ctx.beginPath();
                ctx.moveTo(originX, filmTopY);
                ctx.lineTo(originX + shiftX/2, filmBottomY); // 屈折して進む
                ctx.lineTo(originX + shiftX, filmTopY);      // 裏面反射して戻る
                ctx.lineTo(originX + shiftX + 50, 0);        // 空気中へ
                ctx.stroke();

                // 干渉の結果表示
                // 目のアイコン
                const eyeX = originX + 70;
                const eyeY = -30;
                ctx.font = "30px sans-serif";
                ctx.fillStyle = "black";
                ctx.fillText("👁️", eyeX, 40);

                // 強度インジケーター
                const indX = w * 0.7;
                const indY = h / 2;
                const r = 40;
                
                ctx.beginPath();
                ctx.arc(indX, indY, r, 0, 2 * Math.PI);
                ctx.fillStyle = '#eee';
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.stroke();

                // 結果の色（強度反映）
                ctx.beginPath();
                ctx.arc(indX, indY, r * 0.9, 0, 2 * Math.PI);
                ctx.fillStyle = `rgba(${rayColor.r}, ${rayColor.g}, ${rayColor.b}, ${intensity})`;
                ctx.fill();

                ctx.fillStyle = "#333";
                ctx.font = "16px sans-serif";
                ctx.textAlign = "center";
                ctx.fillText(intensity > 0.8 ? "強め合い（明るい）" : intensity < 0.2 ? "弱め合い（暗い）" : "中間", indX, indY + r + 30);
                
                // 条件式チェック
                // 2nd = (m + 0.5) lambda ?
                const m_approx = (2 * n * d) / lambda - 0.5;
                const m_round = Math.round(m_approx);
                const diff = Math.abs(m_approx - m_round);
                
                ctx.font = "14px sans-serif";
                ctx.fillText(`位相差: ${(phaseDiff/Math.PI).toFixed(2)}π`, indX, indY + r + 50);
            };

            dSlider.addEventListener('input', draw);
            nSlider.addEventListener('input', draw);
            lSlider.addEventListener('input', draw);
            new ResizeObserver(draw).observe(canvas);
            draw();
        };

        // --- 追加セクション: ニュートンリング ---
        const setupNewton = () => {
            const canvas = document.getElementById('newtonCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const rSlider = document.getElementById('newtonR');
            const lSlider = document.getElementById('newtonWavelength');
            const valR = document.getElementById('newtonRValue');
            const valL = document.getElementById('newtonWavelengthValue');

            const draw = () => {
                const w = canvas.width;
                const h = canvas.height;
                const R = parseFloat(rSlider.value); // m
                const lambda = parseFloat(lSlider.value) * 1e-9; // m
                
                valR.textContent = R.toFixed(1);
                valL.textContent = (lambda * 1e9).toFixed(0);

                const color = wavelengthToRgb(lambda * 1e9);
                
                // 画像データの作成（ピクセル操作）
                const imgData = ctx.createImageData(w, h);
                const data = imgData.data;
                const cx = w / 2;
                const cy = h / 2;
                
                // 表示範囲のスケーリング
                // 画面幅 w が物理的なサイズ (例: 1cm = 0.01m) に相当すると仮定
                // Rが大きいと縞が粗くなる。見やすく調整。
                const physicalSize = 0.005; // 5mm
                
                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const dx = (x - cx) / w * physicalSize;
                        const dy = (y - cy) / h * physicalSize;
                        const r_sq = dx*dx + dy*dy;
                        // r = sqrt(r_sq)
                        
                        // 空気層の厚さ t = r^2 / (2R)
                        const t = r_sq / (2 * R);
                        
                        // 反射光の位相差 delta = (4 pi t / lambda) + pi
                        const delta = (4 * Math.PI * t) / lambda + Math.PI;
                        
                        // 強度 I = cos^2(delta / 2)
                        const intensity = Math.pow(Math.cos(delta / 2), 2);
                        
                        const idx = (y * w + x) * 4;
                        data[idx] = color.r * intensity;     // R
                        data[idx + 1] = color.g * intensity; // G
                        data[idx + 2] = color.b * intensity; // B
                        data[idx + 3] = 255; // Alpha
                    }
                }
                ctx.putImageData(imgData, 0, 0);

                // 十字線
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(w, cy); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, h); ctx.stroke();
            };

            rSlider.addEventListener('input', draw);
            lSlider.addEventListener('input', draw);
            draw();
        };

        // --- すべてのシミュレーションを初期化 ---
        setupReflectionAndRefraction();
        setupOpticsSimulations();
        setupYoungsExperiment();
        setupDiffraction();
        setupThinFilm();
        setupNewton();
    });
    </script>
</body>
</html>
