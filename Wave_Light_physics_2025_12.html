<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ç‰©ç†å­¦ç¿’ï¼šå…‰æ³¢ã®ä¸–ç•Œ</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    
    <script>
        MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']],
            processEscapes: true
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #f8fafc;
            color: #1e293b;
        }
        .sticky-nav {
            position: sticky;
            top: 0;
            z-index: 50;
            background-color: rgba(255, 255, 255, 0.85);
            backdrop-filter: blur(8px);
        }
        .section-card {
            background-color: #ffffff;
            border-radius: 0.75rem;
            padding: 2rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.05), 0 2px 4px -2px rgb(0 0 0 / 0.05);
            border: 1px solid #e2e8f0;
        }
        .formula-box {
            background-color: #f0f9ff;
            border: 1px solid #bae6fd;
            border-left: 4px solid #0ea5e9;
            padding: 1rem;
            border-radius: 0.5rem;
            color: #0c4a6e;
        }
        .info-box {
            background-color: #fffbeb;
            border: 1px solid #fde68a;
            border-left: 4px solid #facc15;
            padding: 1rem;
            border-radius: 0.5rem;
            color: #78350f;
        }
        .animation-canvas {
            background-color: #ffffff;
            border-radius: 0.5rem;
            border: 1px solid #e2e8f0;
            cursor: grab;
        }
        .animation-canvas:active {
            cursor: grabbing;
        }
        
        #waveCanvas {
            cursor: crosshair;
            background-color: #000;
        }
        #interferenceCanvas {
            background-color: #fff;
        }
        .control-group {
            margin-bottom: 20px;
        }
        .control-group label {
            margin-bottom: 0.5em;
            font-size: 0.9em;
            color: #555;
        }
        .control-group input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            transition: opacity .2s;
        }
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4a90e2;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .control-group input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4a90e2;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .container {
            width: 100%;
            max-width: 800px;
            background: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            margin-bottom: 2em;
            padding: 1.5em;
            box-sizing: border-box;
        }
        .controls-panel {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 1.5em;
        }
    </style>
</head>
<body class="antialiased">

    <header class="bg-sky-600 text-white text-center py-8">
        <h1 class="text-4xl font-bold">ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ç‰©ç†å­¦ç¿’</h1>
        <p class="text-xl mt-2">å…‰æ³¢ã®ä¸–ç•Œã‚’æ¢æ±‚ã—ã‚ˆã†</p>
    </header>

    <nav class="sticky-nav shadow-md">
        <div class="max-w-6xl mx-auto px-4">
            <div class="flex flex-wrap justify-center items-center gap-x-4 md:gap-x-6 py-3 text-sm md:text-base">
                <a href="#section-reflection-refraction" class="text-gray-600 hover:text-sky-600 font-semibold transition">åå°„ã¨å±ˆæŠ˜</a>
                <a href="#section-lenses" class="text-gray-600 hover:text-sky-600 font-semibold transition">ãƒ¬ãƒ³ã‚ºã®ç§‘å­¦</a>
                <a href="#section-interference" class="text-gray-600 hover:text-sky-600 font-semibold transition">æ³¢ã®å¹²æ¸‰ï¼ˆãƒ¤ãƒ³ã‚°ã®å®Ÿé¨“ï¼‰</a>
            </div>
        </div>
    </nav>

    <main class="max-w-6xl mx-auto p-4 md:p-8 space-y-16">
        
        <section id="section-reflection-refraction" class="section-card">
            <h2 class="text-3xl font-bold text-sky-700 mb-4">å…‰ã®åå°„ã¨å±ˆæŠ˜</h2>
            <p class="mb-6 text-gray-700">å…‰ãŒç•°ãªã‚‹ç‰©è³ªã®å¢ƒç•Œã«é€²ã‚€ã¨ãã€ä¸€éƒ¨ã¯è·³ã­è¿”ã‚Šï¼ˆåå°„ï¼‰ã€ä¸€éƒ¨ã¯ç‰©è³ªã®ä¸­ã«å…¥ã£ã¦é€²ã‚€æ–¹å‘ã‚’å¤‰ãˆã¾ã™ï¼ˆå±ˆæŠ˜ï¼‰ã€‚ã“ã‚Œã‚‰ã®ç¾è±¡ã¯ã€èœƒæ°—æ¥¼ã‚„å…‰ãƒ•ã‚¡ã‚¤ãƒãƒ¼ãªã©ã€èº«ã®å›ã‚Šã®æ§˜ã€…ãªç¾è±¡ã®åŸç†ã¨ãªã£ã¦ã„ã¾ã™ã€‚</p>
            <div class="grid md:grid-cols-2 gap-8">
                <div>
                    <h3 class="text-xl font-semibold mb-2">åå°„ã¨å±ˆæŠ˜ã®æ³•å‰‡ï¼ˆã‚¹ãƒãƒ«ã®æ³•å‰‡ï¼‰</h3>
                    <canvas id="snellCanvas" class="animation-canvas w-full h-64"></canvas>
                     <div class="mt-2">
                        <label for="snellAngle" class="text-sm font-semibold">å…¥å°„è§’ (i): <span id="snellAngleValue">45</span>Â°</label>
                        <input id="snellAngle" type="range" min="0" max="89" value="45" class="w-full">
                     </div>
                      <div class="mt-2">
                        <label for="snellN2" class="text-sm font-semibold">åª’è³ª2ã®å±ˆæŠ˜ç‡ (nâ‚‚): <span id="snellN2Value">1.5</span> (åª’è³ª1: nâ‚=1.0)</label>
                        <input id="snellN2" type="range" min="0.5" max="2.5" value="1.5" step="0.1" class="w-full">
                     </div>
                     <div class="mt-2 formula-box text-center text-sm">$n_1 \sin i = n_2 \sin r$</div>
                </div>
                <div>
                    <h3 class="text-xl font-semibold mb-2">å…¨åå°„ã¨å…‰ãƒ•ã‚¡ã‚¤ãƒãƒ¼</h3>
                    <canvas id="totalInternalReflectionCanvas" class="animation-canvas w-full h-64"></canvas>
                    <div class="mt-2">
                        <label for="tirAngle" class="text-sm font-semibold">å…¥å°„è§’ (i): <span id="tirAngleValue">30</span>Â° (nâ‚=1.5, nâ‚‚=1.0)</label>
                        <input id="tirAngle" type="range" min="0" max="89" value="30" class="w-full">
                    </div>
                    <div class="mt-2 text-center">
                        <p class="text-sm text-gray-600">è‡¨ç•Œè§’ $\theta_c = \sin^{-1}(n_2/n_1) \approx 41.8^\circ$</p>
                        <p id="tirStatus" class="font-bold text-lg mt-2"></p>
                    </div>
                    <p class="text-sm mt-2 text-gray-600">å±ˆæŠ˜ç‡ãŒå¤§ãã„åª’è³ªã‹ã‚‰å°ã•ã„åª’è³ªã¸ã€è‡¨ç•Œè§’ä»¥ä¸Šã®è§’åº¦ã§å…‰ãŒå…¥å°„ã™ã‚‹ã¨ã€å…‰ã¯å±ˆæŠ˜ã›ãšå…¨ã¦åå°„ã—ã¾ã™ï¼ˆå…¨åå°„ï¼‰ã€‚å…‰ãƒ•ã‚¡ã‚¤ãƒãƒ¼ã¯ã“ã®åŸç†ã‚’åˆ©ç”¨ã—ã¦ã„ã¾ã™ã€‚</p>
                </div>
                 <div class="md:col-span-2 mt-4">
                    <h3 class="text-xl font-semibold mb-2">èœƒæ°—æ¥¼ (Mirage)</h3>
                    <canvas id="mirageCanvas" class="animation-canvas w-full h-48"></canvas>
                    <p class="text-sm mt-2 text-gray-600">åœ°è¡¨è¿‘ãã®ç©ºæ°—ãŒæš–ã‚ã‚‰ã‚Œã‚‹ã¨ã€ç©ºæ°—ã®å¯†åº¦ãŒä¸å‡ä¸€ã«ãªã‚Šã€å±ˆæŠ˜ç‡ãŒé€£ç¶šçš„ã«å¤‰åŒ–ã—ã¾ã™ã€‚ã“ã‚Œã«ã‚ˆã‚Šã€é ãã®æ™¯è‰²ã‹ã‚‰ã®å…‰ãŒæ›²ã’ã‚‰ã‚Œã€å®Ÿéš›ã¨ã¯é•ã†å ´æ‰€ã«ã‚ã‚‹ã‚ˆã†ã«è¦‹ãˆãŸã‚Šã€åè»¢ã—ã¦è¦‹ãˆãŸã‚Šã—ã¾ã™ã€‚</p>
                </div>
            </div>
        </section>

        <section id="section-lenses" class="section-card">
            <h2 class="text-3xl font-bold text-sky-700 mb-4">ãƒ¬ãƒ³ã‚ºã®ç§‘å­¦</h2>
            <p class="mb-6 text-gray-700">ãƒ¬ãƒ³ã‚ºã¯å…‰ã‚’å±ˆæŠ˜ã•ã›ã‚‹ã“ã¨ã§ã€ç‰©ä½“ã®åƒã‚’ä½œã‚Šã¾ã™ã€‚ã“ã“ã§ã¯å˜ãƒ¬ãƒ³ã‚ºã‹ã‚‰çµ„ã¿åˆã‚ã›ãƒ¬ãƒ³ã‚ºã¾ã§ã€ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãªã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§ãã®åŸç†ã‚’ä½“é¨“ã—ã¾ã™ã€‚</p>
            <div class="grid md:grid-cols-2 gap-12">
                <div>
                    <h3 class="text-xl font-semibold mb-2">å‡¸ãƒ¬ãƒ³ã‚º (å®Ÿåƒã¨è™šåƒ)</h3>
                    <canvas id="convexLensCanvas" class="animation-canvas w-full h-72"></canvas>
                    <div class="mt-4">
                        <label for="convexObjectDistance" class="font-semibold">ç‰©ä½“è·é›¢ a: <span id="convexObjectDistanceValue">30</span></label>
                        <input type="range" id="convexObjectDistance" min="1" max="50" value="30" step="0.5" class="w-full">
                         <p class="text-sm text-gray-600">ç„¦ç‚¹è·é›¢ f = 15</p>
                    </div>
                    <div id="convexLensInfo" class="mt-2 p-2 bg-gray-100 rounded text-center"></div>
                </div>
                <div>
                    <h3 class="text-xl font-semibold mb-2">å‡¹ãƒ¬ãƒ³ã‚º (è™šåƒ)</h3>
                    <canvas id="concaveLensCanvas" class="animation-canvas w-full h-72"></canvas>
                     <div class="mt-4">
                        <label for="concaveObjectDistance" class="font-semibold">ç‰©ä½“è·é›¢ a: <span id="concaveObjectDistanceValue">30</span></label>
                        <input type="range" id="concaveObjectDistance" min="1" max="50" value="30" step="0.5" class="w-full">
                        <p class="text-sm text-gray-600">ç„¦ç‚¹è·é›¢ f = -15</p>
                    </div>
                    <div id="concaveLensInfo" class="mt-2 p-2 bg-gray-100 rounded text-center"></div>
                </div>
            </div>
             <div class="mt-8">
                <h3 class="text-xl font-semibold mb-2">ãƒ¬ãƒ³ã‚ºã®å…¬å¼ã¾ã¨ã‚</h3>
                 <div class="formula-box text-center text-lg">
                    <p>å†™åƒå…¬å¼: $ \frac{1}{a} + \frac{1}{b} = \frac{1}{f} $ã€€ã€€å€ç‡: $ m = -\frac{b}{a} $</p>
                 </div>
                 <p class="text-sm mt-2 text-gray-600">a: ç‰©ä½“è·é›¢, b: åƒè·é›¢, f: ç„¦ç‚¹è·é›¢ (å‡¸ãƒ¬ãƒ³ã‚ºã¯æ­£, å‡¹ãƒ¬ãƒ³ã‚ºã¯è² )ã€‚bãŒæ­£ãªã‚‰å®Ÿåƒã€è² ãªã‚‰è™šåƒã€‚mãŒæ­£ãªã‚‰æ­£ç«‹åƒã€è² ãªã‚‰å€’ç«‹åƒã€‚</p>
            </div>
             <div class="mt-8">
                 <h3 class="text-xl font-semibold mb-2">çµ„ã¿åˆã‚ã›ãƒ¬ãƒ³ã‚º</h3>
                <canvas id="combinedLensCanvas" class="animation-canvas w-full h-80"></canvas>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mt-4 text-sm">
                    <div>
                        <label for="combinedObjectDistance" class="font-semibold">ç‰©ä½“è·é›¢ $a_1$: <span id="combinedObjectDistanceValue">150</span></label>
                        <input type="range" id="combinedObjectDistance" min="10" max="500" value="150" step="1" class="w-full">
                    </div>
                     <div>
                        <label for="combinedObjectHeight" class="font-semibold">ç‰©ä½“ã®é«˜ã•: <span id="combinedObjectHeightValue">20</span></label>
                        <input type="range" id="combinedObjectHeight" min="-50" max="50" value="20" step="1" class="w-full">
                    </div>
                    <div>
                        <label for="lens1FocalLength" class="font-semibold">ãƒ¬ãƒ³ã‚º1 ç„¦ç‚¹è·é›¢ $f_1$: <span id="lens1FocalLengthValue">100</span></label>
                        <input type="range" id="lens1FocalLength" min="-200" max="200" value="100" step="1" class="w-full">
                    </div>
                     <div>
                        <label for="lens2FocalLength" class="font-semibold">ãƒ¬ãƒ³ã‚º2 ç„¦ç‚¹è·é›¢ $f_2$: <span id="lens2FocalLengthValue">120</span></label>
                        <input type="range" id="lens2FocalLength" min="-200" max="200" value="120" step="1" class="w-full">
                    </div>
                    <div class="lg:col-span-4">
                        <label for="lensSeparation" class="font-semibold">ãƒ¬ãƒ³ã‚ºé–“è·é›¢ d: <span id="lensSeparationValue">250</span></label>
                        <input type="range" id="lensSeparation" min="0" max="500" value="250" step="1" class="w-full">
                    </div>
                </div>
                <div id="combinedLensInfo" class="mt-2 p-2 bg-gray-100 rounded text-center text-sm"></div>
                <div id="combinedLensAdvancedInfo" class="mt-2 p-2 bg-sky-50 border border-sky-200 rounded text-center text-sm text-sky-800"></div>
                <p class="text-sm mt-2 text-gray-600">è¤‡æ•°ã®ãƒ¬ãƒ³ã‚ºã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€ã‚ˆã‚Šè¤‡é›‘ãªå…‰å­¦ç³»ï¼ˆã‚«ãƒ¡ãƒ©ã®ã‚ºãƒ¼ãƒ ãƒ¬ãƒ³ã‚ºã‚„æœ›é é¡ãªã©ï¼‰ã‚’ä½œã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚1æšç›®ã®ãƒ¬ãƒ³ã‚ºãŒä½œã£ãŸåƒã‚’ã€2æšç›®ã®ãƒ¬ãƒ³ã‚ºã®ç‰©ä½“ã¨ã—ã¦è€ƒãˆã¾ã™ã€‚ã‚­ãƒ£ãƒ³ãƒã‚¹ä¸Šã®ç‰©ä½“ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦å‹•ã‹ã™ã“ã¨ã‚‚ã§ãã¾ã™ã‚ˆï¼</p>
            </div>
        </section>

        <section id="section-interference" class="section-card">
            <h2 class="text-3xl font-bold text-sky-700 mb-4">æ³¢ã®å¹²æ¸‰ï¼ˆãƒ¤ãƒ³ã‚°ã®å®Ÿé¨“ï¼‰</h2>
            
            <div class="space-y-8 mb-12">
                <div>
                    <h3 class="text-2xl font-bold text-sky-600 mb-3 border-b-2 border-sky-200 pb-2">æ­´å²ï¼šç²’å­ã‹ã€æ³¢ã‹</h3>
                    <div class="text-gray-700 space-y-4">
                        <p>17ä¸–ç´€ã‹ã‚‰18ä¸–ç´€ã«ã‹ã‘ã¦ã€ç§‘å­¦ç•Œã§ã¯ã‚¢ã‚¤ã‚¶ãƒƒã‚¯ãƒ»ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ³ãŒæå”±ã—ãŸå…‰ã®ã€Œç²’å­èª¬ã€ãŒä¸»æµã§ã—ãŸã€‚å…‰ã‚’å¾®å°ãªç²’å­ã®æµã‚Œã¨è€ƒãˆã‚‹ã“ã®èª¬ã¯ã€å…‰ãŒã¾ã£ã™ãé€²ã‚€ã“ã¨ï¼ˆç›´é€²æ€§ï¼‰ã‚„åå°„ã‚’ã†ã¾ãèª¬æ˜ã§ãã¾ã—ãŸãŒã€ã‚¯ãƒªã‚¹ãƒ†ã‚£ã‚¢ãƒ¼ãƒ³ãƒ»ãƒ›ã‚¤ãƒ˜ãƒ³ã‚¹ã‚‰ãŒæå”±ã—ãŸã€Œæ³¢å‹•èª¬ã€ã¯ã€å…‰ãŒãªãœé®®æ˜ãªå½±ã‚’ä½œã‚‹ã®ã‹ã‚’èª¬æ˜ã™ã‚‹ã®ãŒé›£ã—ãã€å½±ã‚’æ½œã‚ã¦ã„ã¾ã—ãŸã€‚</p>
                        <p>ã“ã®çŠ¶æ³ã‚’è¦†ã—ãŸã®ãŒã€1807å¹´ã®ãƒˆãƒ¼ãƒã‚¹ãƒ»ãƒ¤ãƒ³ã‚°ã«ã‚ˆã‚‹äºŒé‡ã‚¹ãƒªãƒƒãƒˆå®Ÿé¨“ã§ã™ã€‚ã‚‚ã—å…‰ãŒç²’å­ãªã‚‰ã€2ã¤ã®ã‚¹ãƒªãƒƒãƒˆã‚’é€šã‚ŠæŠœã‘ãŸå…‰ã¯ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ä¸Šã«2æœ¬ã®æ˜ã‚‹ã„ç·šã‚’æãã ã‘ã®ã¯ãšã§ã™ã€‚ã—ã‹ã—ã€ãƒ¤ãƒ³ã‚°ãŒå®Ÿéš›ã«è¦³æ¸¬ã—ãŸã®ã¯ã€æ˜ã‚‹ã„éƒ¨åˆ†ã¨æš—ã„éƒ¨åˆ†ãŒäº¤äº’ã«ä¸¦ã¶ã€Œå¹²æ¸‰ç¸ã€ã§ã—ãŸã€‚ã“ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¯ã€æ³¢ãŒå¼·ã‚åˆã£ãŸã‚Šï¼ˆå»ºè¨­çš„å¹²æ¸‰ï¼‰ã€å¼±ã‚åˆã£ãŸã‚Šï¼ˆç ´å£Šçš„å¹²æ¸‰ï¼‰ã™ã‚‹ã“ã¨ã§ã—ã‹ç”Ÿã¾ã‚Œãªã„ã€æ³¢ç‰¹æœ‰ã®ç¾è±¡ã ã£ãŸã®ã§ã™ã€‚ã“ã®ã‚¨ãƒ¬ã‚¬ãƒ³ãƒˆãªå®Ÿé¨“ã¯ã€å…‰ãŒæ³¢ã®æ€§è³ªã‚’æŒã¤ã“ã¨ã‚’æ±ºå®šçš„ã«ç¤ºã—ã€ãƒ‹ãƒ¥ãƒ¼ãƒˆãƒ³ã®æ¨©å¨ã«æŒ‘ã¿ã€è¦³æ¸¬çµæœã“ããŒç§‘å­¦ã®çœŸç†ã‚’åˆ¤æ–­ã™ã‚‹ã¨ã„ã†åŸå‰‡ã‚’æ”¹ã‚ã¦ç¤ºã™ç”»æœŸçš„ãªå‡ºæ¥äº‹ã¨ãªã‚Šã¾ã—ãŸã€‚</p>
                    </div>
                </div>

                <div>
                    <h3 class="text-2xl font-bold text-sky-600 mb-3 border-b-2 border-sky-200 pb-2">æ•°å¼ã¨ãã®èª¬æ˜</h3>
                    <div class="space-y-6">
                        <div>
                            <h4 class="text-xl font-semibold mb-2">çµŒè·¯å·®ã¨å¹²æ¸‰æ¡ä»¶</h4>
                            <p class="text-gray-700 mb-4">ãƒ¤ãƒ³ã‚°ã®å®Ÿé¨“ã®éµã¯ã€2ã¤ã®ã‚¹ãƒªãƒƒãƒˆï¼ˆSâ‚ã¨Sâ‚‚ï¼‰ã‹ã‚‰ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ä¸Šã®ã‚ã‚‹ç‚¹ï¼ˆPï¼‰ã¾ã§ã®è·é›¢ã®å·®ã€ã¤ã¾ã‚Š<strong class="text-sky-600">çµŒè·¯å·®</strong> $\Delta l = |S_2P - S_1P|$ ã§ã™ã€‚ã“ã®çµŒè·¯å·®ãŒã€å…‰ã®æ³¢é•· $\lambda$ ã®æ•´æ•°å€ã«ãªã‚‹ã‹ã€åŠæ•´æ•°å€ã«ãªã‚‹ã‹ã§ã€å…‰ãŒå¼·ã‚åˆã†ã‹å¼±ã‚åˆã†ã‹ãŒæ±ºã¾ã‚Šã¾ã™ã€‚</p>
                            <div class="grid md:grid-cols-2 gap-4">
                                <div class="formula-box">
                                    <p class="font-bold text-center">æ˜ç·šã®æ¡ä»¶ï¼ˆå¼·ã‚åˆã„ï¼‰</p>
                                    <p class="text-center mt-2 text-lg">$\Delta l = m\lambda$</p>
                                    <p class="text-sm mt-1 text-center">($m = 0, 1, 2, \dots$)</p>
                                </div>
                                <div class="formula-box">
                                    <p class="font-bold text-center">æš—ç·šã®æ¡ä»¶ï¼ˆå¼±ã‚åˆã„ï¼‰</p>
                                    <p class="text-center mt-2 text-lg">$\Delta l = (m + \frac{1}{2})\lambda$</p>
                                    <p class="text-sm mt-1 text-center">($m = 0, 1, 2, \dots$)</p>
                                </div>
                            </div>
                        </div>
                        
                        <div>
                            <h4 class="text-xl font-semibold mb-2">çµŒè·¯å·®ã®è¿‘ä¼¼å¼</h4>
                            <p class="text-gray-700 mb-4">ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‹ã‚‰ã‚¹ãƒªãƒƒãƒˆã¾ã§ã®è·é›¢ã‚’ $L$ã€ã‚¹ãƒªãƒƒãƒˆã®é–“éš”ã‚’ $d$ã€ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ä¸­å¿ƒã‹ã‚‰æ¸¬ã£ãŸè·é›¢ã‚’ $x$ ã¨ã—ã¾ã™ã€‚å®Ÿéš›ã®å®Ÿé¨“ã§ã¯ã€$L$ ã¯ $d$ ã‚„ $x$ ã«æ¯”ã¹ã¦éå¸¸ã«å¤§ãã„ ($L \gg d, L \gg x$) ãŸã‚ã€çµŒè·¯å·® $\Delta l$ ã¯ä»¥ä¸‹ã®éå¸¸ã«ä¾¿åˆ©ãªå¼ã§è¿‘ä¼¼ã§ãã¾ã™ã€‚</p>
                             <div class="formula-box text-center text-lg">
                                $\Delta l \approx \frac{dx}{L}$
                             </div>
                             <div class="info-box mt-4">
                                <p class="font-bold mb-2">ğŸ’¡ è¿‘ä¼¼å¼ã®å°å‡ºï¼ˆå¹¾ä½•å­¦çš„è€ƒå¯Ÿï¼‰</p>
                                <p class="text-sm text-gray-700">ã“ã®è¿‘ä¼¼ã¯ã€$L$ ãŒéå¸¸ã«é•·ã„ãŸã‚ã«ã€2ã¤ã®ã‚¹ãƒªãƒƒãƒˆã‹ã‚‰ç‚¹Pã¸å‘ã‹ã†2æœ¬ã®å…‰ç·šãŒã»ã¼å¹³è¡Œã ã¨è¦‹ãªã›ã‚‹ã“ã¨ã‹ã‚‰å°ã‹ã‚Œã¾ã™ã€‚ã“ã®ã¨ãã€çµŒè·¯å·® $\Delta l$ ã¯ã€ã‚¹ãƒªãƒƒãƒˆé–“éš” $d$ ã¨å…‰ç·šã®è§’åº¦ $\theta$ ã‚’ç”¨ã„ã¦ $\Delta l = d \sin\theta$ ã¨è¡¨ã›ã¾ã™ã€‚ã•ã‚‰ã«ã€è§’åº¦ $\theta$ ãŒéå¸¸ã«å°ã•ã„ã®ã§ã€$\sin\theta \approx \tan\theta$ ã¨ã„ã†è¿‘ä¼¼ãŒæˆã‚Šç«‹ã¡ã¾ã™ã€‚å›³å½¢ã‹ã‚‰ $\tan\theta = \frac{x}{L}$ ãªã®ã§ã€ã“ã‚Œã‚‰ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã¨ $\Delta l \approx d \cdot \frac{x}{L}$ ã¨ãªã‚Šã¾ã™ã€‚ç‰©ç†å­¦ã§ã¯ã€ã“ã†ã„ã†è³¢ã„ã€Œè¿‘ä¼¼ã€ãŒã€è¤‡é›‘ãªç¾è±¡ã‚’ã‚·ãƒ³ãƒ—ãƒ«ã«ç†è§£ã™ã‚‹ä¸Šã§ã¨ã¦ã‚‚é‡è¦ãªã‚“ã§ã™ã‚ˆã€‚</p>
                            </div>
                            </div>
                        
                        <div>
                            <h4 class="text-xl font-semibold mb-2">å¹²æ¸‰ç¸ã®é–“éš”</h4>
                            <p class="text-gray-700 mb-4">ä¸Šè¨˜ã®è¿‘ä¼¼å¼ã¨æ˜ç·šã®æ¡ä»¶ã‚’çµ„ã¿åˆã‚ã›ã‚‹ã“ã¨ã§ã€ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ä¸­å¿ƒã‹ã‚‰ $m$ ç•ªç›®ã®æ˜ç·šã¾ã§ã®è·é›¢ $x_m$ ã¯ã€æ¬¡ã®ã‚ˆã†ã«è¡¨ã•ã‚Œã¾ã™ã€‚</p>
                             <div class="formula-box text-center text-lg">
                                $x_m = \frac{m\lambda L}{d}$
                             </div>
                             <p class="text-gray-700 my-4">ã“ã®å¼ã‹ã‚‰ã€éš£ã‚Šåˆã†æ˜ç·šã®é–“éš” $\Delta x$ ã¯ã€$m$ ã®å€¤ã«ã‚ˆã‚‰ãšã©ã“ã§ã‚‚ä¸€å®šã«ãªã‚‹ã“ã¨ãŒã‚ã‹ã‚Šã¾ã™ã€‚ã“ã®é–¢ä¿‚å¼ãŒã€ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®æ ¸å¿ƒã¨ãªã‚Šã¾ã™ã€‚</p>
                             <div class="formula-box text-center text-lg">
                                $\Delta x = x_{m+1} - x_m = \frac{\lambda L}{d}$
                             </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="youngs-experiment-app">
                 <div class="container">
                    <h3 class="text-xl font-semibold mb-4 text-center">ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ«</h3>
                    <div class="controls-panel">
                        <div class="control-group">
                            <label for="wavelength">å…‰ã®æ³¢é•· (Î»): <span id="wavelengthValue">550</span> nm</label>
                            <input type="range" id="wavelength" min="400" max="700" value="550">
                        </div>
                        <div class="control-group">
                            <label for="slitSeparation">ã‚¹ãƒªãƒƒãƒˆé–“éš” (d): <span id="slitSeparationValue">0.25</span> mm</label>
                            <input type="range" id="slitSeparation" min="0.01" max="0.5" value="0.25" step="0.001">
                        </div>
                        <div class="control-group">
                            <label for="screenDistance">ã‚¹ã‚¯ãƒªãƒ¼ãƒ³è·é›¢ (L): <span id="screenDistanceValue">2.5</span> m</label>
                            <input type="range" id="screenDistance" min="0.5" max="5.0" value="2.5" step="0.1">
                        </div>
                    </div>
                </div>
                <div class="container">
                    <h3 class="text-xl font-semibold mb-4 text-center">æ³¢ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ (ãƒã‚¦ã‚¹ã‚’ä¹—ã›ã¦çµŒè·¯å·®ã‚’ç¢ºèª)</h3>
                    <canvas id="waveCanvas" width="800" height="400"></canvas>
                </div>
                <div class="container">
                    <h3 class="text-xl font-semibold mb-4 text-center">å¹²æ¸‰ç¸ã®å¼·åº¦åˆ†å¸ƒã‚°ãƒ©ãƒ•</h3>
                    <canvas id="interferenceCanvas" width="800" height="200"></canvas>
                </div>
            </div>
        </section>
    </main>

    <footer class="text-center py-6 bg-gray-100 mt-16">
        <p class="text-gray-500">ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ç‰©ç†å­¦ç¿’ | å…‰æ³¢ã®ä¸–ç•Œ</p>
    </footer>

    <script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- Smooth Scrolling ---
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth' });
                }
            });
        });

        // --- å…±é€šãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•° ---
        const resizeCanvas = (canvas) => {
            if (!canvas) return false;
            const { width, height } = canvas.getBoundingClientRect();
            if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width;
                canvas.height = height;
                return true;
            }
            return false;
        };
        
        // --- â–¼â–¼â–¼ åå°„ã¨å±ˆæŠ˜ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— â–¼â–¼â–¼ ---
        const setupReflectionAndRefraction = () => {
            const snellCanvas = document.getElementById('snellCanvas');
            if (snellCanvas) {
                const ctx = snellCanvas.getContext('2d');
                const angleSlider = document.getElementById('snellAngle');
                const n2Slider = document.getElementById('snellN2');
                const angleValue = document.getElementById('snellAngleValue');
                const n2Value = document.getElementById('snellN2Value');
                const drawSnell = () => {
                    resizeCanvas(snellCanvas);
                    const w = snellCanvas.width, h = snellCanvas.height, i_deg = parseFloat(angleSlider.value), n1 = 1.0, n2 = parseFloat(n2Slider.value);
                    angleValue.textContent = i_deg.toFixed(0); n2Value.textContent = n2.toFixed(2);
                    const i_rad = i_deg * Math.PI / 180, sin_r = (n1 / n2) * Math.sin(i_rad);
                    let r_rad = Math.asin(sin_r);
                    ctx.clearRect(0, 0, w, h);
                    ctx.fillStyle = 'rgba(14, 165, 233, 0.1)'; ctx.fillRect(0, h/2, w, h/2);
                    ctx.fillStyle = '#0c4a6e'; ctx.fillText('åª’è³ª1 (nâ‚=1.0)', 10, 20); ctx.fillText(`åª’è³ª2 (nâ‚‚=${n2.toFixed(2)})`, 10, h - 10);
                    const originX = w/2, originY = h/2, rayLength = w/2;
                    ctx.beginPath(); ctx.setLineDash([5, 5]); ctx.moveTo(originX, 0); ctx.lineTo(originX, h); ctx.strokeStyle = '#9ca3af'; ctx.stroke(); ctx.setLineDash([]);
                    ctx.beginPath(); ctx.moveTo(0, originY); ctx.lineTo(w, originY); ctx.strokeStyle = '#374151'; ctx.lineWidth = 2; ctx.stroke();
                    const incidentX = originX - rayLength * Math.sin(i_rad), incidentY = originY - rayLength * Math.cos(i_rad);
                    ctx.beginPath(); ctx.moveTo(incidentX, incidentY); ctx.lineTo(originX, originY); ctx.strokeStyle = '#f97316'; ctx.lineWidth = 3; ctx.stroke();
                    const reflectedX = originX + rayLength * Math.sin(i_rad), reflectedY = originY - rayLength * Math.cos(i_rad);
                    ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(reflectedX, reflectedY); ctx.strokeStyle = '#fb923c'; ctx.lineWidth = 2; ctx.globalAlpha = 0.8; ctx.stroke(); ctx.globalAlpha = 1.0;
                    if (Math.abs(sin_r) <= 1) {
                        const refractedX = originX + rayLength * Math.sin(r_rad), refractedY = originY + rayLength * Math.cos(r_rad);
                        ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(refractedX, refractedY); ctx.strokeStyle = '#f97316'; ctx.lineWidth = 3; ctx.stroke();
                    }
                };
                angleSlider.addEventListener('input', drawSnell); n2Slider.addEventListener('input', drawSnell); 
                new ResizeObserver(drawSnell).observe(snellCanvas); drawSnell();
            }
            const tirCanvas = document.getElementById('totalInternalReflectionCanvas');
            if (tirCanvas) {
                const ctx = tirCanvas.getContext('2d');
                const angleSlider = document.getElementById('tirAngle');
                const angleValue = document.getElementById('tirAngleValue');
                const statusText = document.getElementById('tirStatus');
                const n1 = 1.5, n2 = 1.0, criticalAngleDeg = Math.asin(n2 / n1) * 180 / Math.PI;
                const drawTIR = () => {
                    resizeCanvas(tirCanvas);
                    const w = tirCanvas.width, h = tirCanvas.height, i_deg = parseFloat(angleSlider.value);
                    angleValue.textContent = i_deg.toFixed(0);
                    const i_rad = i_deg * Math.PI / 180;
                    ctx.clearRect(0, 0, w, h);
                    ctx.fillStyle = 'rgba(14, 165, 233, 0.1)'; ctx.fillRect(0, 0, w, h/2);
                    ctx.fillStyle = '#0c4a6e'; ctx.fillText(`åª’è³ª2 (ç©ºæ°—, nâ‚‚=${n2.toFixed(1)})`, 10, 20); ctx.fillText(`åª’è³ª1 (ã‚¬ãƒ©ã‚¹, nâ‚=${n1.toFixed(1)})`, 10, h - 10);
                    const originX = w / 2, originY = h / 2, rayLength = w / 2;
                    ctx.beginPath(); ctx.setLineDash([5, 5]); ctx.moveTo(originX, 0); ctx.lineTo(originX, h); ctx.strokeStyle = '#9ca3af'; ctx.stroke(); ctx.setLineDash([]);
                    ctx.beginPath(); ctx.moveTo(0, originY); ctx.lineTo(w, originY); ctx.strokeStyle = '#374151'; ctx.lineWidth = 2; ctx.stroke();
                    const incidentX = originX - rayLength * Math.sin(i_rad), incidentY = originY + rayLength * Math.cos(i_rad);
                    ctx.beginPath(); ctx.moveTo(incidentX, incidentY); ctx.lineTo(originX, originY); ctx.strokeStyle = '#16a34a'; ctx.lineWidth = 3; ctx.stroke();
                    const reflectedX = originX + rayLength * Math.sin(i_rad), reflectedY = originY + rayLength * Math.cos(i_rad);
                    if (i_deg > criticalAngleDeg) {
                        statusText.textContent = 'å…¨åå°„'; statusText.className = 'font-bold text-lg mt-2 text-red-500';
                        ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(reflectedX, reflectedY); ctx.strokeStyle = '#16a34a'; ctx.lineWidth = 3; ctx.stroke();
                    } else {
                        statusText.textContent = 'ä¸€éƒ¨åå°„ãƒ»ä¸€éƒ¨å±ˆæŠ˜'; statusText.className = 'font-bold text-lg mt-2 text-blue-500';
                        ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(reflectedX, reflectedY); ctx.strokeStyle = '#4ade80'; ctx.lineWidth = 2; ctx.globalAlpha = 0.7; ctx.stroke(); ctx.globalAlpha = 1.0;
                        const sin_r = (n1 / n2) * Math.sin(i_rad), r_rad = Math.asin(sin_r);
                        const refractedX = originX + rayLength * Math.sin(r_rad), refractedY = originY - rayLength * Math.cos(r_rad);
                        ctx.beginPath(); ctx.moveTo(originX, originY); ctx.lineTo(refractedX, refractedY); ctx.strokeStyle = '#16a34a'; ctx.lineWidth = 3; ctx.stroke();
                    }
                };
                angleSlider.addEventListener('input', drawTIR); 
                new ResizeObserver(drawTIR).observe(tirCanvas); drawTIR();
            }
            const mirageCanvas = document.getElementById('mirageCanvas');
            if(mirageCanvas) {
                const ctx = mirageCanvas.getContext('2d');
                let time = 0;
                const drawMirage = () => {
                    resizeCanvas(mirageCanvas);
                    const w = mirageCanvas.width, h = mirageCanvas.height;
                    ctx.clearRect(0, 0, w, h);
                    const sky = ctx.createLinearGradient(0, 0, 0, h); sky.addColorStop(0, '#87ceeb'); sky.addColorStop(1, '#f0f8ff');
                    ctx.fillStyle = sky; ctx.fillRect(0, 0, w, h);
                    ctx.fillStyle = '#d2b48c'; ctx.fillRect(0, h * 0.8, w, h * 0.2);
                    const treeX = w * 0.8, treeY = h * 0.8;
                    ctx.fillStyle = '#8B4513'; ctx.fillRect(treeX, treeY - 50, 10, 50);
                    ctx.fillStyle = '#008000'; ctx.beginPath(); ctx.arc(treeX + 5, treeY - 50, 25, Math.PI, 2 * Math.PI); ctx.fill();
                    ctx.save(); ctx.globalAlpha = 0.5; ctx.translate(treeX, treeY); ctx.scale(1, -1);
                    ctx.fillStyle = '#8B4513'; ctx.fillRect(0, -2, 10, 50);
                    ctx.fillStyle = '#008000'; ctx.beginPath(); ctx.arc(5, -50, 25, Math.PI, 2 * Math.PI); ctx.fill();
                    ctx.restore();
                    ctx.beginPath(); ctx.moveTo(treeX, treeY - 60);
                    ctx.quadraticCurveTo(w * 0.5, h * 0.8 + 10 + Math.sin(time) * 2, w * 0.1, h * 0.6);
                    ctx.strokeStyle = `rgba(255, 255, 100, ${0.5 + Math.sin(time * 1.5) * 0.2})`;
                    ctx.lineWidth = 2; ctx.setLineDash([3, 3]); ctx.stroke(); ctx.setLineDash([]);
                    ctx.fillStyle = 'black'; ctx.fillText('ğŸ‘ï¸', w * 0.1 - 15, h * 0.6 + 5);
                    time += 0.05; requestAnimationFrame(drawMirage);
                };
                drawMirage();
            }
        };

        // --- â–¼â–¼â–¼ ãƒ¬ãƒ³ã‚ºã‚»ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— â–¼â–¼â–¼ ---
        const setupLensSimulations = () => {
            function calculateSystemProperties(f1, f2, d) {
                const combinedFocalLength = (f1 * f2) / (f1 + f2 - d);
                const h1_pos = (combinedFocalLength * d) / f2;
                const h2_pos = -(combinedFocalLength * d) / f1;
                return { combinedFocalLength, h1_pos, h2_pos };
            }

            function traceSystem(objectDist, objectHeight, f1, f2, d) {
                if (Math.abs(objectDist - f1) < 1e-6) {
                    return { finalImage: null, intermediateImage: null, totalMag: Infinity };
                }
                const image1Dist = 1 / (1 / f1 - 1 / objectDist);
                const mag1 = -image1Dist / objectDist;
                const image1Height = objectHeight * mag1;
                const intermediateImage = { distance: image1Dist, height: image1Height };

                const object2Dist = d - image1Dist;

                if (Math.abs(object2Dist - f2) < 1e-6) {
                    return { finalImage: null, intermediateImage, totalMag: Infinity };
                }
                const image2Dist = 1 / (1 / f2 - 1 / object2Dist);
                const mag2 = -image2Dist / object2Dist;
                const finalImageHeight = image1Height * mag2;
                const finalImage = { distance: image2Dist, height: finalImageHeight };
                const totalMag = mag1 * mag2;

                return { finalImage, intermediateImage, totalMag };
            }

            const drawArrow = (ctx, x, y_base, height, color, lineWidth, isDashed = false) => {
                if (!isFinite(height)) return;
                const tipY = y_base - height; const wingOffset = height > 0 ? 7 : -7;
                ctx.beginPath(); ctx.moveTo(x, y_base); ctx.lineTo(x, tipY);
                ctx.moveTo(x, tipY); ctx.lineTo(x - 5, tipY + wingOffset);
                ctx.moveTo(x, tipY); ctx.lineTo(x + 5, tipY + wingOffset);
                ctx.strokeStyle = color; ctx.lineWidth = lineWidth;
                if (isDashed) { ctx.setLineDash([4, 4]); }
                ctx.stroke(); ctx.setLineDash([]);
            };
            
            const drawLensShape = (ctx, x, y, height, f) => {
                 const bulge = 15; const topY = y - height/2, bottomY = y + height/2;
                 ctx.strokeStyle = '#3b82f6'; ctx.lineWidth = 2; ctx.fillStyle = 'rgba(191, 219, 254, 0.5)';
                 ctx.beginPath();
                 if (f > 0) {
                     ctx.moveTo(x, topY);
                     ctx.bezierCurveTo(x + bulge, topY + height/3, x + bulge, bottomY - height/3, x, bottomY);
                     ctx.bezierCurveTo(x - bulge, bottomY - height/3, x - bulge, topY + height/3, x, topY);
                 } else {
                     const edgeWidth = 12; const centerWidth = 4;
                     ctx.moveTo(x - edgeWidth, topY);
                     ctx.quadraticCurveTo(x - centerWidth, y, x - edgeWidth, bottomY);
                     ctx.lineTo(x + edgeWidth, bottomY);
                     ctx.quadraticCurveTo(x + centerWidth, y, x + edgeWidth, topY);
                     ctx.closePath();
                 }
                 ctx.closePath(); ctx.fill(); ctx.stroke();
            };
            
            const drawConvexLensSystem = (canvas, slider, infoDiv, f) => {
                const ctx = canvas.getContext('2d');
                const valueSpan = slider.previousElementSibling.querySelector('span');
                
                const draw = () => {
                    resizeCanvas(canvas);
                    const w = canvas.width, h = canvas.height, scale = w / 100, centerY = h / 2, centerX = w / 2;
                    const a = parseFloat(slider.value);
                    valueSpan.textContent = a.toFixed(1);

                    let b, m;
                    if (Math.abs(a - f) < 0.1) { b = Infinity; m = Infinity; } 
                    else { b = 1 / (1/f - 1/a); m = -b / a; }

                    ctx.clearRect(0, 0, w, h);
                    
                    const objectHeight = 20, objectX = centerX - a * scale;
                    const imageX = centerX + b * scale, imageHeight = objectHeight * m;
                    const rayStartY = centerY - objectHeight;
                    const imageTipY = centerY - imageHeight;

                    ctx.beginPath(); ctx.moveTo(0, centerY); ctx.lineTo(w, centerY); ctx.strokeStyle = '#9ca3af'; ctx.lineWidth = 1; ctx.stroke();
                    drawLensShape(ctx, centerX, centerY, h*0.8, f);

                    const focusF2_x = centerX + f * scale, focusF1_x = centerX - f * scale;
                    ctx.fillStyle = '#ef4444';
                    ctx.fillText('Fâ‚‚', focusF2_x - 3, centerY - 10); ctx.beginPath(); ctx.arc(focusF2_x, centerY, 3, 0, 2*Math.PI); ctx.fill();
                    ctx.fillText("Fâ‚", focusF1_x - 10, centerY - 10); ctx.beginPath(); ctx.arc(focusF1_x, centerY, 3, 0, 2*Math.PI); ctx.fill();
                    
                    drawArrow(ctx, objectX, centerY, objectHeight, '#f97316', 3);

                    if (isFinite(b)) {
                        drawArrow(ctx, imageX, centerY, imageHeight, b > 0 ? '#16a34a' : '#6d28d9', 3, b < 0);
                        ctx.lineWidth = 1;

                        ctx.strokeStyle = '#d946ef';
                        ctx.beginPath();
                        ctx.moveTo(objectX, rayStartY);
                        ctx.lineTo(centerX, rayStartY);
                        if (b > 0) {
                            ctx.lineTo(imageX, imageTipY);
                        } else {
                            const slope = (rayStartY - imageTipY) / (centerX - imageX);
                            ctx.lineTo(w, rayStartY + slope * (w-centerX));
                        }
                        ctx.stroke();

                        ctx.strokeStyle = '#22c55e';
                        ctx.beginPath();
                        ctx.moveTo(objectX, rayStartY);
                        if (b > 0) {
                             ctx.lineTo(imageX, imageTipY);
                        } else {
                            ctx.lineTo(w, centerY + (centerY - rayStartY) / (centerX - objectX) * (w - centerX));
                        }
                        ctx.stroke();
                        
                        if (b < 0) {
                            ctx.save();
                            ctx.setLineDash([2, 3]);
                            ctx.strokeStyle = '#a3a3a3';
                            ctx.beginPath(); ctx.moveTo(imageX, imageTipY); ctx.lineTo(centerX, rayStartY); ctx.stroke();
                            ctx.beginPath(); ctx.moveTo(imageX, imageTipY); ctx.lineTo(objectX, rayStartY); ctx.stroke();
                            ctx.restore();
                        }
                    }

                    let infoText = `åƒè·é›¢ b: ${isFinite(b)?b.toFixed(1):'âˆ'}<br>å€ç‡ m: ${isFinite(m)?m.toFixed(2):'âˆ'}<br>`;
                    if (isFinite(b)) { infoText += `ç¨®é¡: ${b>0?'å®Ÿåƒ':'è™šåƒ'}, ${m<0?'å€’ç«‹':'æ­£ç«‹'}`; } 
                    else { infoText += 'åƒã¯ã§ããªã„'; }
                    infoDiv.innerHTML = infoText;
                };
                slider.addEventListener('input', draw);
                new ResizeObserver(draw).observe(canvas);
                draw();
            };
            
            const drawConcaveLensSystem = (canvas, slider, infoDiv, f) => {
                const ctx = canvas.getContext('2d');
                const valueSpan = slider.previousElementSibling.querySelector('span');

                const draw = () => {
                    resizeCanvas(canvas);
                    const w = canvas.width, h = canvas.height, scale = w / 100, centerY = h / 2, centerX = w / 2;
                    const a = parseFloat(slider.value);
                    valueSpan.textContent = a.toFixed(1);

                    const b = 1 / (1/f - 1/a);
                    const m = -b / a;

                    ctx.clearRect(0, 0, w, h);

                    const objectHeight = 40, objectX = centerX - a * scale, imageX = centerX + b * scale, imageHeight = objectHeight * m;
                    const rayStartY = centerY - objectHeight;
                    const imageTipY = centerY - imageHeight;

                    ctx.beginPath(); ctx.moveTo(0, centerY); ctx.lineTo(w, centerY); ctx.strokeStyle = '#9ca3af'; ctx.lineWidth = 1; ctx.stroke();
                    drawLensShape(ctx, centerX, centerY, h*0.8, f);
                   
                    const focusF1_x = centerX + f * scale, focusF2_x = centerX - f*scale; 
                    ctx.fillStyle = '#ef4444';
                    ctx.fillText('Fâ‚', focusF1_x - 10, centerY - 10); ctx.beginPath(); ctx.arc(focusF1_x, centerY, 3, 0, 2 * Math.PI); ctx.fill();
                    ctx.fillText("Fâ‚‚", focusF2_x - 3, centerY - 10); ctx.beginPath(); ctx.arc(focusF2_x, centerY, 3, 0, 2 * Math.PI); ctx.fill();
                    
                    drawArrow(ctx, objectX, centerY, objectHeight, '#f97316', 3);
                    drawArrow(ctx, imageX, centerY, imageHeight, '#6d28d9', 3, true);
                    
                    ctx.lineWidth = 1;

                    ctx.strokeStyle = '#d946ef'; 
                    ctx.beginPath(); 
                    ctx.moveTo(objectX, rayStartY); ctx.lineTo(centerX, rayStartY);
                    const slope1 = (rayStartY - centerY) / (centerX - focusF1_x);
                    ctx.lineTo(w, rayStartY + slope1 * (w - centerX)); 
                    ctx.stroke();
                    
                    ctx.strokeStyle = '#22c55e';
                    ctx.beginPath(); 
                    ctx.moveTo(objectX, rayStartY); 
                    const slope2 = (rayStartY - centerY) / (objectX - centerX);
                    ctx.lineTo(w, centerY + slope2 * (w - centerX));
                    ctx.stroke();

                    ctx.save(); 
                    ctx.setLineDash([2, 3]); 
                    ctx.strokeStyle = '#a3a3a3';
                    ctx.beginPath(); ctx.moveTo(imageX, imageTipY); ctx.lineTo(centerX, rayStartY); ctx.stroke();
                    ctx.beginPath(); ctx.moveTo(imageX, imageTipY); ctx.lineTo(objectX, rayStartY); ctx.stroke();
                    ctx.restore();

                    let infoText = `åƒè·é›¢ b: ${b.toFixed(1)}<br>å€ç‡ m: ${m.toFixed(2)}<br>`;
                    infoText += `ç¨®é¡: è™šåƒ, æ­£ç«‹`;
                    infoDiv.innerHTML = infoText;
                };
                slider.addEventListener('input', draw);
                new ResizeObserver(draw).observe(canvas);
                draw();
            };

            const setupCombinedLensSystem = () => {
                const canvas = document.getElementById('combinedLensCanvas');
                if (!canvas) return;
                const ctx = canvas.getContext('2d');
                
                const sliders = { a1: document.getElementById('combinedObjectDistance'), h1: document.getElementById('combinedObjectHeight'), f1: document.getElementById('lens1FocalLength'), f2: document.getElementById('lens2FocalLength'), d: document.getElementById('lensSeparation') };
                const values = { a1: document.getElementById('combinedObjectDistanceValue'), h1: document.getElementById('combinedObjectHeightValue'), f1: document.getElementById('lens1FocalLengthValue'), f2: document.getElementById('lens2FocalLengthValue'), d: document.getElementById('lensSeparationValue') };
                
                const infoDiv = document.getElementById('combinedLensInfo');
                const advancedInfoDiv = document.getElementById('combinedLensAdvancedInfo');

                let config = { object: { distance: 100, height: 20 }, lens1: { focalLength: 50 }, lens2: { focalLength: 60 }, separation: 185, };
                let isDragging = false, dragStartX = 0, initialObjectDistance = config.object.distance;

                const draw = () => {
                    resizeCanvas(canvas);
                    const w = canvas.width, h = canvas.height, scale = w / 600, centerY = h / 2;
                    const { object, lens1, lens2, separation } = config;

                    values.a1.textContent = object.distance.toFixed(1); values.h1.textContent = object.height.toFixed(1);
                    values.f1.textContent = lens1.focalLength.toFixed(1); values.f2.textContent = lens2.focalLength.toFixed(1); values.d.textContent = separation.toFixed(1);

                    const traceResult = traceSystem(object.distance, object.height, lens1.focalLength, lens2.focalLength, separation);
                    const systemProps = calculateSystemProperties(lens1.focalLength, lens2.focalLength, separation);
                    const { finalImage, intermediateImage, totalMag } = traceResult;

                    ctx.clearRect(0, 0, w, h);

                    const lens1X = w / 2 - (separation / 2) * scale, lens2X = w / 2 + (separation / 2) * scale;
                    const objectX = lens1X - object.distance * scale, rayStartY = centerY - object.height * scale;
                    const intermediateImageX = intermediateImage ? lens1X + intermediateImage.distance * scale : NaN;
                    const intermediateImageY = intermediateImage ? centerY - intermediateImage.height * scale : NaN;
                    const finalImageX = finalImage ? lens2X + finalImage.distance * scale : NaN;
                    const finalImageY = finalImage ? centerY - finalImage.height * scale : NaN;

                    ctx.beginPath(); ctx.moveTo(0, centerY); ctx.lineTo(w, centerY); ctx.strokeStyle = '#9ca3af'; ctx.lineWidth = 1; ctx.setLineDash([2, 2]); ctx.stroke(); ctx.setLineDash([]);
                    drawLensShape(ctx, lens1X, centerY, h * 0.9, lens1.focalLength);
                    drawLensShape(ctx, lens2X, centerY, h * 0.9, lens2.focalLength);
                    
                    ctx.fillStyle = '#ef4444';
                    const f1_x = lens1X - lens1.focalLength * scale, f1_prime_x = lens1X + lens1.focalLength * scale;
                    const f2_x = lens2X - lens2.focalLength * scale, f2_prime_x = lens2X + lens2.focalLength * scale;
                    ctx.fillText("Fâ‚", f1_x - 10, centerY - 10); ctx.beginPath(); ctx.arc(f1_x, centerY, 3, 0, 2*Math.PI); ctx.fill();
                    ctx.fillText("Fâ‚'", f1_prime_x - 5, centerY - 10); ctx.beginPath(); ctx.arc(f1_prime_x, centerY, 3, 0, 2*Math.PI); ctx.fill();
                    ctx.fillText("Fâ‚‚", f2_x - 10, centerY - 10); ctx.beginPath(); ctx.arc(f2_x, centerY, 3, 0, 2*Math.PI); ctx.fill();
                    ctx.fillText("Fâ‚‚'", f2_prime_x - 5, centerY - 10); ctx.beginPath(); ctx.arc(f2_prime_x, centerY, 3, 0, 2*Math.PI); ctx.fill();

                    drawArrow(ctx, objectX, centerY, object.height * scale, '#f97316', 3);
                    if (intermediateImage) { drawArrow(ctx, intermediateImageX, centerY, intermediateImage.height * scale, '#fb923c', 2, true); }
                    if (finalImage) { drawArrow(ctx, finalImageX, centerY, finalImage.height * scale, totalMag < 0 ? '#16a34a' : '#6d28d9', 3); }
                    
                    ctx.lineWidth = 1; ctx.globalAlpha = 0.7;

                    ctx.strokeStyle = '#d946ef'; ctx.beginPath(); ctx.moveTo(objectX, rayStartY); ctx.lineTo(lens1X, rayStartY);
                    if (isFinite(intermediateImageX)) {
                        ctx.lineTo(intermediateImageX, intermediateImageY); ctx.lineTo(lens2X, intermediateImageY);
                        if (isFinite(finalImageX)) { ctx.lineTo(finalImageX, finalImageY); } 
                        else { const slope = (intermediateImageY - centerY) / (lens2X - f2_x); ctx.lineTo(w, intermediateImageY + slope * (w-lens2X)); }
                    } else { ctx.lineTo(w, rayStartY); }
                    ctx.stroke();

                    ctx.strokeStyle = '#22c55e'; ctx.beginPath(); ctx.moveTo(objectX, rayStartY);
                    if (isFinite(intermediateImageX)) {
                        ctx.lineTo(intermediateImageX, intermediateImageY); ctx.lineTo(finalImageX, finalImageY);
                    } else { const slope = (rayStartY-centerY)/(lens1X - objectX); ctx.lineTo(w, centerY + slope * (w-lens1X)); }
                    ctx.stroke();
                    ctx.globalAlpha = 1.0;

                    const formatNum = (n) => isFinite(n) ? n.toFixed(1) : 'âˆ';
                    infoDiv.innerHTML = `ä¸­é–“åƒ bâ‚: ${formatNum(intermediateImage?.distance)}, mâ‚: ${formatNum(intermediateImage ? -intermediateImage.distance/object.distance : Infinity)} | ç‰©ä½“ aâ‚‚: ${formatNum(intermediateImage ? separation - intermediateImage.distance : 'âˆ')}<br>æœ€çµ‚åƒ bâ‚‚: ${formatNum(finalImage?.distance)}, ç·åˆå€ç‡ M: ${formatNum(totalMag)}`;
                    advancedInfoDiv.innerHTML = `åˆæˆç„¦ç‚¹è·é›¢ f: ${formatNum(systemProps.combinedFocalLength)} | ä¸»å¹³é¢Hâ‚ (Lâ‚ã‹ã‚‰): ${formatNum(systemProps.h1_pos)}, Hâ‚‚ (Lâ‚‚ã‹ã‚‰): ${formatNum(systemProps.h2_pos)}`;
                };
                
                const updateConfig = (key, value) => {
                     const newConfig = { ...config }; const keys = key.split('.');
                     if (keys.length === 2) { newConfig[keys[0]][keys[1]] = value; } else { newConfig[keys[0]] = value; }
                     config = newConfig; if(sliders[keys[0]]) sliders[keys[0]].value = value;
                     draw();
                };

                for (const key in sliders) {
                    const fullKey = key === 'a1' ? 'object.distance' : key === 'h1' ? 'object.height' : key === 'f1' ? 'lens1.focalLength' : key === 'f2' ? 'lens2.focalLength' : 'separation';
                    sliders[key].addEventListener('input', (e) => updateConfig(fullKey, parseFloat(e.target.value)));
                }
                
                canvas.addEventListener('mousedown', (e) => { isDragging = true; dragStartX = e.clientX; initialObjectDistance = config.object.distance; canvas.style.cursor = 'grabbing'; });
                window.addEventListener('mouseup', () => { isDragging = false; canvas.style.cursor = 'grab'; });
                window.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const dx = e.clientX - dragStartX; const scale = canvas.width / 600; const newDist = initialObjectDistance - (dx / scale);
                        if (newDist > 0) { updateConfig('object.distance', newDist); }
                    }
                });

                new ResizeObserver(draw).observe(canvas);
                draw();
            }

            const convexLensCanvas = document.getElementById('convexLensCanvas');
            if (convexLensCanvas) { drawConvexLensSystem(convexLensCanvas, document.getElementById('convexObjectDistance'), document.getElementById('convexLensInfo'), 15); }

            const concaveLensCanvas = document.getElementById('concaveLensCanvas');
            if (concaveLensCanvas) { drawConcaveLensSystem(concaveLensCanvas, document.getElementById('concaveObjectDistance'), document.getElementById('concaveLensInfo'), -15); }

            setupCombinedLensSystem();
        };

        const setupYoungsExperiment = () => {
       	    const waveCanvas = document.getElementById('waveCanvas');
            if (!waveCanvas) return;
	    const waveCtx = waveCanvas.getContext('2d');
	    const interferenceCanvas = document.getElementById('interferenceCanvas');
	    const interferenceCtx = interferenceCanvas.getContext('2d');
	    
	    const wavelengthSlider = document.getElementById('wavelength');
	    const slitSeparationSlider = document.getElementById('slitSeparation');
	    const screenDistanceSlider = document.getElementById('screenDistance');
	    
	    const wavelengthValue = document.getElementById('wavelengthValue');
	    const slitSeparationValue = document.getElementById('slitSeparationValue');
	    const screenDistanceValue = document.getElementById('screenDistanceValue');

	    let params = {};
	    let scale = {};
	    let t = 0;
	    let animationId;
	    let mousePos = null;
	    let screenX = 0;
	    const waveSpeed = 0.25;
	    
	    function setup() {
		updateParams();
		addEventListeners();
		startAnimation();
	    }
	    function updateParams() {
		params.lambda = parseFloat(wavelengthSlider.value);
		params.d = parseFloat(slitSeparationSlider.value);
		params.L = parseFloat(screenDistanceSlider.value);
        
		const physicalWidthMM = 5; 
		scale.pxPerMM = waveCanvas.width / physicalWidthMM;
		scale.mmPerPx = physicalWidthMM / waveCanvas.width;
		
		wavelengthValue.textContent = params.lambda.toFixed(0);
		slitSeparationValue.textContent = params.d.toFixed(3);
		screenDistanceValue.textContent = params.L.toFixed(1);

		const minL = 0.5, maxL = 5.0;
		const minScreenX = waveCanvas.width * 0.25;
		const maxScreenX = waveCanvas.width * 0.95;
		screenX = minScreenX + ((params.L - minL) / (maxL - minL)) * (maxScreenX - minScreenX);
        
		const color = wavelengthToRgb(params.lambda);
		const thumbStyle = `
            input[type="range"]#wavelength::-webkit-slider-thumb { background: rgb(${color.r}, ${color.g}, ${color.b}); }
            input[type="range"]#wavelength::-moz-range-thumb { background: rgb(${color.r}, ${color.g}, ${color.b}); }
        `;
		let styleSheet = document.getElementById('slider-color-style');
		if (!styleSheet) {
		    styleSheet = document.createElement('style');
		    styleSheet.id = 'slider-color-style';
		    document.head.appendChild(styleSheet);
		}
		styleSheet.textContent = thumbStyle;
	    }

	    function addEventListeners() {
		[wavelengthSlider, slitSeparationSlider, screenDistanceSlider].forEach(slider => {
		    slider.addEventListener('input', updateParams);
		});
		
		waveCanvas.addEventListener('mousemove', e => {
		    const rect = waveCanvas.getBoundingClientRect();
		    mousePos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
		});
		waveCanvas.addEventListener('mouseleave', () => { mousePos = null; });
	    }

	    function animate() {
		t += 1;
		drawWaves();
		drawInterferenceGraph();
		if (mousePos) {
		    drawPathDifference(mousePos.x, mousePos.y);
		}
		animationId = requestAnimationFrame(animate);
	    }
    
	    function startAnimation() {
		if (animationId) cancelAnimationFrame(animationId);
		animate();
	    }
    
	    function drawWaves() {
		const width = waveCanvas.width;
		const height = waveCanvas.height;

		waveCtx.fillStyle = 'black';
		waveCtx.fillRect(0, 0, width, height);

		const slitYCenter = height / 2;
		const slitX = width * 0.1;
		const slitSeparationPx = params.d * scale.pxPerMM;
		const s1 = { x: slitX, y: slitYCenter - slitSeparationPx / 2 };
		const s2 = { x: slitX, y: slitYCenter + slitSeparationPx / 2 };
        
		const base_lambda_px = 10;
		const visual_lambda_px = base_lambda_px * (params.lambda / 400.0);
		const color = wavelengthToRgb(params.lambda);
		waveCtx.strokeStyle = `rgba(${color.r}, ${color.g}, ${color.b}, 0.8)`;
		waveCtx.lineWidth = 2;

		const maxRadius = width;
		const phaseOffset = (t * waveSpeed) % visual_lambda_px;

		[s1, s2].forEach(slit => {
		    for (let r = phaseOffset; r < maxRadius; r += visual_lambda_px) {
			waveCtx.beginPath();
			waveCtx.arc(slit.x, slit.y, r, 0, 2 * Math.PI);
			waveCtx.stroke();
		    }
		});

		const slitVisualWidthPx = 12;
		waveCtx.strokeStyle = 'rgba(200, 200, 200, 0.9)';
		waveCtx.lineWidth = 4;
        
		waveCtx.beginPath();
		waveCtx.moveTo(slitX, 0);
		waveCtx.lineTo(slitX, s1.y - slitVisualWidthPx / 2);
		waveCtx.moveTo(slitX, s1.y + slitVisualWidthPx / 2);
		waveCtx.lineTo(slitX, s2.y - slitVisualWidthPx / 2);
		waveCtx.moveTo(slitX, s2.y + slitVisualWidthPx / 2);
		waveCtx.lineTo(slitX, height);
		waveCtx.stroke();
	
		waveCtx.fillStyle = "white";
		waveCtx.beginPath();
		waveCtx.arc(s1.x, s1.y, 4, 0, 2 * Math.PI);
		waveCtx.arc(s2.x, s2.y, 4, 0, 2 * Math.PI);
		waveCtx.fill();
        
		for (let y_px = 0; y_px < height; y_px++) {
		    const dx1 = screenX - s1.x, dy1 = y_px - s1.y;
		    const dx2 = screenX - s2.x, dy2 = y_px - s2.y;
		    const r1_px = Math.sqrt(dx1*dx1 + dy1*dy1);
		    const r2_px = Math.sqrt(dx2*dx2 + dy2*dy2);
		    const pathDiff_px = Math.abs(r1_px - r2_px);
		    const phaseDiff_visual = (2 * Math.PI * pathDiff_px) / visual_lambda_px;
		    const intensity = Math.pow(Math.cos(phaseDiff_visual / 2), 2);
		    waveCtx.fillStyle = `rgba(${color.r}, ${color.g}, ${color.b}, ${intensity})`;
		    waveCtx.fillRect(screenX, y_px, 50, 1);
		}
        
		waveCtx.beginPath();
		waveCtx.moveTo(screenX, 0);
		waveCtx.lineTo(screenX, height);
		waveCtx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
		waveCtx.lineWidth = 4;
		waveCtx.setLineDash([6, 6]);
		waveCtx.stroke();
		waveCtx.setLineDash([]);
        
		waveCtx.save();
		waveCtx.translate(screenX - 15, height / 2); 
		waveCtx.rotate(-Math.PI / 2);
		waveCtx.font = 'bold 14px "Noto Sans JP", sans-serif';
		waveCtx.fillStyle = 'rgba(255, 255, 255, 0.9)';
		waveCtx.textAlign = 'center';
		waveCtx.fillText('ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ (Screen)', 0, 0);
		waveCtx.restore();
        
		const arrowY = height - 20;
		waveCtx.beginPath();
		waveCtx.moveTo(slitX, arrowY);
		waveCtx.lineTo(screenX, arrowY);
		waveCtx.moveTo(slitX + 5, arrowY - 5); waveCtx.lineTo(slitX, arrowY); waveCtx.lineTo(slitX + 5, arrowY + 5);
		waveCtx.moveTo(screenX - 5, arrowY - 5); waveCtx.lineTo(screenX, arrowY); waveCtx.lineTo(screenX - 5, arrowY + 5);
		waveCtx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
		waveCtx.lineWidth = 1.5;
		waveCtx.stroke();
		waveCtx.font = '14px "Noto Sans JP", sans-serif';
		waveCtx.fillStyle = 'white';
		waveCtx.textAlign = 'center';
		waveCtx.fillText(`L = ${params.L.toFixed(1)} m (æ¨¡å¼å›³)`, (slitX + screenX) / 2, arrowY - 10);
	    }

	    function drawInterferenceGraph() {
		const graphWidth = interferenceCanvas.width;
		const graphHeight = interferenceCanvas.height;
		interferenceCtx.clearRect(0, 0, graphWidth, graphHeight);

		interferenceCtx.beginPath();
		for (let i = 0; i <= 10; i++) {
		    const y = (i / 10) * graphHeight;
		    interferenceCtx.moveTo(0, y);
		    interferenceCtx.lineTo(graphWidth, y);
		}
		for (let i = 0; i <= 20; i++) {
		    const x = (i / 20) * graphWidth;
		    interferenceCtx.moveTo(x, 0);
		    interferenceCtx.lineTo(x, graphHeight);
		}
		interferenceCtx.strokeStyle = '#e0e0e0';
		interferenceCtx.lineWidth = 0.5;
		interferenceCtx.stroke();

		const waveWidth = waveCanvas.width;
		const waveHeight = waveCanvas.height;
		
		const slitYCenter = waveHeight / 2;
		const slitX = waveWidth * 0.1;
		const slitSeparationPx = params.d * scale.pxPerMM;
		const s1 = { x: slitX, y: slitYCenter - slitSeparationPx / 2 };
		const s2 = { x: slitX, y: slitYCenter + slitSeparationPx / 2 };
        
		const base_lambda_px = 15;
		const visual_lambda_px = base_lambda_px * (params.lambda / 400.0);
		const color = wavelengthToRgb(params.lambda);

		interferenceCtx.beginPath();
		interferenceCtx.moveTo(0, graphHeight);

		for (let i = 0; i < graphWidth; i++) {
		    const rangeMultiplier = 2.5;
		    const y_center = waveHeight / 2;
		    const totalRange = waveHeight * rangeMultiplier;
		    const y_px = y_center - (totalRange / 2) + (i / graphWidth) * totalRange;
            
		    const dx1 = screenX - s1.x, dy1 = y_px - s1.y;
		    const dx2 = screenX - s2.x, dy2 = y_px - s2.y;
		    const r1_px = Math.sqrt(dx1*dx1 + dy1*dy1);
		    const r2_px = Math.sqrt(dx2*dx2 + dy2*dy2);
		    const pathDiff_px = Math.abs(r1_px - r2_px);
		    const phaseDiff_visual = (2 * Math.PI * pathDiff_px) / visual_lambda_px;
		    const interferenceEffect = Math.pow(Math.cos(phaseDiff_visual / 2), 2);

		    const slitWidthPx = (params.d * scale.pxPerMM) * 0.2;
		    const theta = Math.atan2(y_px - waveHeight / 2, screenX - slitX);
		    const beta = (Math.PI * slitWidthPx * Math.sin(theta)) / visual_lambda_px;
            
		    let diffractionEffect = 1.0;
		    if (Math.abs(beta) > 1e-6) {
			diffractionEffect = Math.pow(Math.sin(beta) / beta, 2);
		    }
            
		    const intensity = interferenceEffect * diffractionEffect;
		    
		    const y_graph = (1 - intensity) * graphHeight * 0.9 + graphHeight * 0.05;
		    interferenceCtx.lineTo(i, y_graph);
		}
        
		interferenceCtx.strokeStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;
		interferenceCtx.lineWidth = 3;
		interferenceCtx.stroke();
		
		interferenceCtx.fillStyle = '#333';
		interferenceCtx.font = '12px sans-serif';
		interferenceCtx.textAlign = 'center';
        
		const screenPhysicalHeightMM = 40; 
		for (let mm = -20; mm <= 20; mm += 10) {
		    const pixelX = (mm + screenPhysicalHeightMM / 2) / screenPhysicalHeightMM * graphWidth;
		    
		    interferenceCtx.beginPath();
		    interferenceCtx.moveTo(pixelX, graphHeight * 0.95);
		    interferenceCtx.lineTo(pixelX, graphHeight);
		    interferenceCtx.strokeStyle = '#ccc';
		    interferenceCtx.lineWidth = 1;
		    interferenceCtx.stroke();
		    interferenceCtx.fillText(mm.toString(), pixelX, graphHeight - 15);
		}
		interferenceCtx.textAlign = 'right';
		interferenceCtx.fillText("(mm)", graphWidth - 5, graphHeight - 5);
	    }            

	    function drawPathDifference(targetX, targetY) {
		const slitYCenter = waveCanvas.height / 2;
		const slitX = waveCanvas.width * 0.1;
		const slitSeparationPx = params.d * scale.pxPerMM;
		const s1 = { x: slitX, y: slitYCenter - slitSeparationPx / 2 };
		const s2 = { x: slitX, y: slitYCenter + slitSeparationPx / 2 };
		waveCtx.beginPath();
		waveCtx.arc(targetX, targetY, 5, 0, 2 * Math.PI);
		waveCtx.fillStyle = 'rgba(255, 255, 0, 0.8)';
		waveCtx.fill();
		waveCtx.beginPath();
		waveCtx.moveTo(s1.x, s1.y); waveCtx.lineTo(targetX, targetY);
		waveCtx.moveTo(s2.x, s2.y); waveCtx.lineTo(targetX, targetY);
		waveCtx.strokeStyle = 'rgba(255, 255, 0, 0.7)';
		waveCtx.lineWidth = 1.5;
		waveCtx.stroke();
		const dx1 = targetX - s1.x, dy1 = targetY - s1.y;
		const dx2 = targetX - s2.x, dy2 = targetY - s2.y;
		const r1_px = Math.sqrt(dx1 * dx1 + dy1 * dy1);
		const r2_px = Math.sqrt(dx2 * dx2 + dy2 * dy2);
		const base_lambda_px = 15;
		const visual_lambda_px = base_lambda_px * (params.lambda / 400.0);
		const pathDiff_px = Math.abs(r1_px - r2_px);
		const pathDiffInWavelengths = pathDiff_px / visual_lambda_px;
		
        // â–¼â–¼â–¼ ã“ã“ã‹ã‚‰ä¿®æ­£ â–¼â–¼â–¼
        // ã‚¹ã‚¯ãƒªãƒ¼ãƒ³æç”»ã¨åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ã§å…‰ã®å¼·åº¦ã‚’è¨ˆç®—
        const phaseDiff_visual = (2 * Math.PI * pathDiff_px) / visual_lambda_px;
        const intensity = Math.pow(Math.cos(phaseDiff_visual / 2), 2);

		let conditionText = '';
        // å¼·åº¦ã«åŸºã¥ã„ã¦ã€Œå¼·ã‚åˆã„ã€ã€Œå¼±ã‚åˆã„ã€ã‚’åˆ¤å®šã—ã€è¡¨ç¤ºã¨ä½“æ„Ÿã‚’ä¸€è‡´ã•ã›ã‚‹
		if (intensity > 0.8) {
		    conditionText = `å¼·ã‚åˆã„ (æ˜ã‚‹ã„ç¸)`;
		} else if (intensity < 0.2) {
		    conditionText = `å¼±ã‚åˆã„ (æš—ã„ç¸)`;
		}
        // â–²â–²â–² ã“ã“ã¾ã§ä¿®æ­£ â–²â–²â–²

		waveCtx.font = 'bold 14px "Noto Sans JP", sans-serif';
		waveCtx.fillStyle = 'white';
		waveCtx.shadowColor = 'black'; waveCtx.shadowBlur = 4;
		const text1 = `çµŒè·¯å·®: æ³¢é•·ã®${pathDiffInWavelengths.toFixed(2)}å€`;
		waveCtx.fillText(text1, targetX + 15, targetY - 10);
		if (conditionText) {
		    waveCtx.fillStyle = (conditionText.includes('å¼·ã‚')) ? '#86E3CE' : '#FFC0CB';
		    waveCtx.fillText(conditionText, targetX + 15, targetY + 10);
		}
		waveCtx.shadowBlur = 0;
	    }

	    function wavelengthToRgb(wavelength) {
		let r, g, b;
		if (wavelength >= 380 && wavelength <= 440) { r = -(wavelength - 440) / (440 - 380); g = 0.0; b = 1.0; } 
		else if (wavelength > 440 && wavelength <= 490) { r = 0.0; g = (wavelength - 440) / (490 - 440); b = 1.0; } 
		else if (wavelength > 490 && wavelength <= 510) { r = 0.0; g = 1.0; b = -(wavelength - 510) / (510 - 490); } 
		else if (wavelength > 510 && wavelength <= 580) { r = (wavelength - 510) / (580 - 510); g = 1.0; b = 0.0; } 
		else if (wavelength > 580 && wavelength <= 645) { r = 1.0; g = -(wavelength - 645) / (645 - 580); b = 0.0; } 
		else if (wavelength > 645 && wavelength <= 780) { r = 1.0; g = 0.0; b = 0.0; } 
		else { r = 0.0; g = 0.0; b = 0.0; }
		let factor = 1.0;
		if (wavelength > 700) { factor = 0.3 + 0.7 * (780 - wavelength) / (780 - 700); } 
		else if (wavelength < 420) { factor = 0.3 + 0.7 * (wavelength - 380) / (420 - 380); } 
		else { factor = 1.0; }
		return { r: Math.round(255 * (r * factor)), g: Math.round(255 * (g * factor)), b: Math.round(255 * (b * factor)) };
	    }
            setup();
        };

        // --- ã™ã¹ã¦ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åˆæœŸåŒ– ---
        setupReflectionAndRefraction();
        setupLensSimulations();
        setupYoungsExperiment();
    });
    </script>
</body>
</html>
